# SpringCloud（一）

代码完成情况：优秀

- 有收获     希望：有自己计划。
- 手艺（技术）
- 意识
- 强制



课程回顾：

1、springboot的自动配置的使用

- 程序中添加依赖：spring-boot-starter-xxx   or   xxx-spring-boot-starter
  - 项目启动：bean就会自动注册到spring  IoC容器中
- 程序中：可以直接使用    注入相关的bean。

2、spring 条件注解：@Conditional

- 判断条件是否成立
  - 成立：注册bean
  - 不成立：不注册

3、springboot中：提供了很多的条件注解    @ConditionalOnClass/Bean   OnMissingClass/Bean

- 源码：spring-boot-starter-autoconfiguration      data.RedisAutoConfiguration

4、加载第三方bean的三种方式    开发：启动类的包以及子包【约定大于配置】

- 使用包扫描：@ComponentScan
- 导入配置类：@Import
- 自定义@EnableXxx注解：本质上还是导入配置类

5、@Import的使用

- 直接导入Bean：    特点，bean的名称==该类的全限定名称

- 直接导入配置类：略

- ```
  导入ImportSelector接口实现类    bean的名称==该类的全限定名称
  ```

- ```
  导入ImportBeanDefinitionRegistrar接口实现类    bean的名称：可以自定义
  ```

6、@EnableAutoConfiguration：自动配置注解

- 加载META-INF/spring.factories
- spring.factories：key=values(v1,v2,v3....)     value：都是一些配置类   <spring.xml   bean>
- XxxAutoConfiguration   注册bean

7、自定了starter     参考mybatis模板开发的   略。

8、springboot的监听器

- 项目启动的时候执行
- 分类：
  - 系统级别：配置文件指定加载
  - **应用级别**：@Component        场景：缓存预热。

9、springboot的监控：略      管控台       查看程序的运行情况（beans\evn\jmm等等）

10、springboot程序打包：jar/war





学习目标：掌握的

1、SpringCloud介绍

- 项目架构的演变过程

2、使用RestTemplate发送请求

3、搭建Eureka注册中心

4、使用Ribbon实现负载均衡

5、使用Hystrix熔断器：服务降级





# 1 SpringCloud介绍

## 1.1 项目架构演变过程

### 1.1.1 单一的应用架构

![1562658341708](./总img/畅购前置课三/1562658341708.png)

- 模块之间耦合度太高，其中一个升级其他都得升级
-  开发困难，各个团队开发最后都要整合一起
- 系统的扩展性差
- 不能灵活的进行分布式部署

### 1.1.2 垂直的应用架构

当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，**将应用拆成互不相干的几个应用**，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。 

### 1.1.3 系统拆分

#### 1.1.3.1 先看一段对话

![1562657555510](./总img/畅购前置课三/1562657555510.png)

#### 1.1.3.2 系统拆分

1）  **应用间耦合严重**。系统内各个应用之间不通，同样一个功能在各个应用中都有实现，后果就是改一处功能，需要同时改系统中的所有应用。这种情况多存在于历史较长的系统，因各种原因，系统内的各个应用都形成了自己的业务小闭环

2）  **业务扩展性差**。数据模型从设计之初就只支持某一类的业务，来了新类型的业务后又得重新写代码实现，结果就是项目延期，大大影响业务的接入速度；

3）  **代码老旧，难以维护**。各种随意的if else、写死逻辑散落在应用的各个角落，处处是坑，开发维护起来战战兢兢；

4）  **系统扩展性差**。系统支撑现有业务已是颤颤巍巍，不论是应用还是DB都已经无法承受业务快速发展带来的压力；

5）  **新坑越挖越多，恶性循环**。不改变的话，最终的结果就是把系统做死了。

![1562657589625](./总img/畅购前置课三/1562657589625.png)

#### 1.1.3.3 拆分原则

##### 1.1.3.3.1 把握业务复杂度

一个老生常谈的问题，系统与业务的关系？

![1562657906176](./总img/畅购前置课三/1562657906176.png)

我们最期望的理想情况是第一种关系（车辆与人），业务觉得不合适，可以马上换一辆新的。但现实的情况是更像心脏起搏器与人之间的关系，不是说换就能换。一个系统接的业务越多，耦合越紧密。如果在没有真正把握住业务复杂度之前贸然行动，最终的结局就是把心脏带飞。 

##### 1.1.3.3.2 高内聚-低耦合-单一职责

业务复杂度把握后，需要开始定义各个应用的服务边界。怎么才算是好的边界？像葫芦娃兄弟一样的应用就是好的！

举个例子，葫芦娃兄弟（应用）间的技能是相互独立的，遵循单一职责原则，比如水娃只能喷水，火娃只会喷火，隐形娃不会喷水喷火但能隐身。更为关键的是，葫芦娃兄弟最终可以合体为金刚葫芦娃，即这些应用虽然功能彼此独立，但又相互打通，最后合体在一起就成了我们的平台。

![1562657945336](./总img/畅购前置课三/1562657945336.png)

这里很多人会有疑惑，拆分粒度怎么控制？很难有一个明确的结论，只能说是结合业务场景、目标、进度的一个折中。但总体的原则是先从一个大的服务边界开始，不要太细，因为随着架构、业务的演进，应用自然而然会再次拆分，让正确的事情自然发生才最合理。

##### 1.1.3.3.3 确定拆分后的应用目标

一旦系统的宏观应用拆分图出来后，就要落实到某一具体的应用拆分上了。首先要确定的就是某一应用拆分后的目标。拆分优化是没有底的，可能越做越深，越做越没结果，继而又影响自己和团队的士气。比如说可以定这期的目标就是将db、应用分拆出去，数据模型的重新设计可以在第二期。

##### 1.1.3.3.4 拆分后应用的状态以及存在的风险

**动手前的思考成本远远低于动手后遇到问题的解决成本**。应用拆分最怕的是中途说“他*的，这块不能动，原来当时这样设计是有原因的，得想别的路子！”这时的压力可想而知，整个节奏不符合预期后，很可能会接二连三遇到同样的问题，这时不仅同事们士气下降，自己也会丧失信心，继而可能导致拆分失败。 

##### 1.1.3.3.5 留个锦囊 

锦囊就四个字“有备无患”，可以贴在桌面或者手机上。在以后具体实施过程中，多思考下“方案是否有多种可以选择？复杂问题能否拆解？实际操作时是否有预案？”，应用拆分在具体实践过程中比拼得就是细致二字，多一份方案，多一份预案，不仅能提升成功概率，更给自己信心。 

### 1.1.4 SOA架构

![1562658477029](./总img/畅购前置课三/1562658477029.png)

典型代表有两个：流动计算架构和微服务架构；

**流动计算架构：**

当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。流动计算架构的最佳实践阿里的Dubbo。

**微服务架构**

与流动计算架构很相似，除了具备流动计算架构优势外，微服务架构中的微服务可以独立部署，独立发展。且微服务的开发不会限制于任何技术栈。微服务架构的最佳实践是SpringCloud。



**单一的应用架构--->垂直的应用架构--->分布式架构--->SOA面向服务--->微服务架构**

![1562658148351](./总img/畅购前置课三/1562658148351.png)

![1562657038085](./总img/畅购前置课三/1562657038085.png)

![项目架构](D:\Java笔记_Typora\我添加的img\项目架构-1606641221600.png)

## 1.2 SpringCloud

![1562658525176](./总img/畅购前置课三/1562658525176.png)

### 1.2.1 介绍

Spring Cloud是在Spring Boot的基础上构建的，用于简化分布式系统构建的**工具集**。该工具集为微服务架构中所涉及的配置管理、服务发现、智能路由、熔断器、控制总线等操作提供了一种简单的开发方式。也就是说Spring Cloud把非常流行的微服务的技术整合到一起，方便开发。例如：

![1562658769580](./总img/畅购前置课三/1562658769580.png)

- 注册中心：Eureka
- 负载均衡：Ribbon
- 熔断器：Hystrix
- 服务通信：Feign
- 网关：Gateway
- 配置中心 ：config
- 消息总线：Bus



### 1.2.2 版本

Spring Cloud的版本号并不像其他Spring项目是通过数字来区分版本号的（如Spring 5.0.2），而是根据英文字母的顺序，采用伦敦的“地名+版本号”的方式来命名的，例如Greenwich SR2 、Finchley SR3 、Edgware SR6 、Dalston SR5等。其中Greenwich 、Finchley 等是地名，而SR是Service Releases的缩写，是固定的写法，后面的数字是小版本号。（PS：小提示：由于Spring Cloud的版本更新很快，所以在学习时可能会发现官网中正式版本的小版本号可能与书中的并不一致，这是很正常的） 

![1562658911028](./总img/畅购前置课三/1562658911028.png)

- SNAPSHOT：快照版本，尝鲜版，随时可能修改
- M版本，MileStone，M1表示第一个里程碑版本，一般同时标注PRE，表示预览版
- SR，Service Release，SR1表示第一个正式版本，同时标注GA(Generally Available)，通用版

### 1.2.3 与SpringBoot版本匹配关系

鉴于SpringBoot与SpringCloud关系，SpringBoot建议采用2.1.x版本

| SpringBoot | SpringCloud                      |
| ---------- | -------------------------------- |
| 1.2.x      | Angel版本                        |
| 1.3.x      | Brixton版本                      |
| 1.4.x      | Camden版本                       |
| 1.5.x      | Dalston版本、Edgware             |
| 2.0.x      | Finchley版本                     |
| 2.1.x      | Greenwich GA版本 (2019年2月发布) |

总结：

1、springcloud是一个工具箱     每个工具解决不同的问题。

2、springcloud的版本需要与springboot的版本对应。



# 2 使用RestTemplate发送请求

![1606529305896](./总img/畅购前置课三/1606529305896.png)





## 2.1 介绍

Spring RestTemplate 是 Spring 提供的用于访问 Rest 服务的客户端，RestTemplate 提供了多种便捷访问远程Http服务的方法，能够大大提高客户端的编写效率，所以很多客户端比如 Android或者第三方接口调用都可以使用 RestTemplate 请求 restful 服务。 它的底层是对**HttpClient**进行了封装。

- RestTemplate是Rest的HTTP客户端模板工具类
- 对基于Http的客户端进行封装
- 实现对象与JSON串的相互转换

常见的HTTP客户端工具：**HttpClient**、OKHttp、URLConnection。

## 2.2 HTTP客户端工具

### 2.2.1 在工程中添加HttpClient依赖

创建工程`<springcloud-day01-demo1-resttemplate>`并且在pom文件中添加依赖：

~~~xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.1.4.RELEASE</version>
    <relativePath/>
</parent>
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>

    <!--httpclient依赖-->
    <dependency>
        <groupId>org.apache.httpcomponents</groupId>
        <artifactId>httpclient</artifactId>
    </dependency>
</dependencies>
~~~



### 2.2.2 在工程中添加HttpClient工具类

在`<com.itheima.util>包下添加工具类`

![1589635144181](./总img/畅购前置课三/1589635144181.png)

~~~java
package com.itheima.util;

import java.io.IOException;
import java.security.GeneralSecurityException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.text.ParseException;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.apache.http.Consts;
import org.apache.http.HttpEntity;
import org.apache.http.NameValuePair;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLContextBuilder;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.conn.ssl.TrustStrategy;
import org.apache.http.conn.ssl.X509HostnameVerifier;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.util.EntityUtils;

/**
 * http请求客户端
 * 
 * @author itcast
 * 
 */
public class HttpClient {
	private String url;
	private Map<String, String> param;
	private int statusCode;
	private String content;
	private String xmlParam;
	private boolean isHttps;

	public boolean isHttps() {
		return isHttps;
	}

	public void setHttps(boolean isHttps) {
		this.isHttps = isHttps;
	}

	public String getXmlParam() {
		return xmlParam;
	}

	public void setXmlParam(String xmlParam) {
		this.xmlParam = xmlParam;
	}

	public HttpClient(String url, Map<String, String> param) {
		this.url = url;
		this.param = param;
	}

	public HttpClient(String url) {
		this.url = url;
	}

	public void setParameter(Map<String, String> map) {
		param = map;
	}

	public void addParameter(String key, String value) {
		if (param == null){
			param = new HashMap<String, String>();
		}

		param.put(key, value);
	}

	public void post() throws ClientProtocolException, IOException {
		HttpPost http = new HttpPost(url);
		setEntity(http);
		execute(http);
	}

	public void put() throws ClientProtocolException, IOException {
		HttpPut http = new HttpPut(url);
		setEntity(http);
		execute(http);
	}

	public void get() throws ClientProtocolException, IOException {
		if (param != null) {
			StringBuilder url = new StringBuilder(this.url);
			boolean isFirst = true;
			for (String key : param.keySet()) {
				if (isFirst){
					url.append("?");
				}
				else{
					url.append("&");
				}

				url.append(key).append("=").append(param.get(key));
			}
			this.url = url.toString();
		}
		HttpGet http = new HttpGet(url);
		execute(http);
	}

	/**
	 * set http post,put param
	 */
	private void setEntity(HttpEntityEnclosingRequestBase http) {
		if (param != null) {
			List<NameValuePair> nvps = new LinkedList<NameValuePair>();
			for (String key : param.keySet()){
				nvps.add(new BasicNameValuePair(key, param.get(key))); // 参数
			}

			http.setEntity(new UrlEncodedFormEntity(nvps, Consts.UTF_8)); // 设置参数
		}
		if (xmlParam != null) {
			http.setEntity(new StringEntity(xmlParam, Consts.UTF_8));
		}
	}

	private void execute(HttpUriRequest http) throws ClientProtocolException,
			IOException {
		CloseableHttpClient httpClient = null;
		try {
			if (isHttps) {
				SSLContext sslContext = new SSLContextBuilder()
						.loadTrustMaterial(null, new TrustStrategy() {
							// 信任所有
							@Override
							public boolean isTrusted(X509Certificate[] chain,
									String authType)
									throws CertificateException {
								return true;
							}
						}).build();
				SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(
						sslContext);
				httpClient = HttpClients.custom().setSSLSocketFactory(sslsf)
						.build();
			} else {
				httpClient = HttpClients.createDefault();
			}
			CloseableHttpResponse response = httpClient.execute(http);
			try {
				if (response != null) {
					if (response.getStatusLine() != null){
						statusCode = response.getStatusLine().getStatusCode();
					}

					HttpEntity entity = response.getEntity();
					// 响应内容
					content = EntityUtils.toString(entity, Consts.UTF_8);
				}
			} finally {
				response.close();
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			httpClient.close();
		}
	}

	public int getStatusCode() {
		return statusCode;
	}

	public String getContent() throws ParseException, IOException {
		return content;
	}

}

~~~



### 2.2.3 测试

创建一个测试类进行测试：

![1589635857830](./总img/畅购前置课三/1589635857830.png)

~~~java
public class HttpClientTest {

    @Test
    public void test() throws Exception {
        // 创建HttpClient，指定请求的url并且发送请求
        String url = "http://localhost:8080/user/findUsers";
        HttpClient httpClient = new HttpClient(url);
        httpClient.get();   // get请求

        // 发送请求
        String content = httpClient.getContent();
        System.out.println(content);
    }
}
~~~



测试结果：

![1589635832396](./总img/畅购前置课三/1589635832396.png)



## 2.3 RestTemplate入门程序

### 2.3.1 添加依赖

在【2.2章节】的工程`<springcloud-day01-demo1-resttemplate>`中添加依赖：

~~~xml
<!--web依赖中包含了RestTemplate-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
~~~



### 2.3.2 注入RestTemplate

在SpringBoot启动类注入RestTemplate。

![1589636023167](./总img/畅购前置课三/1589636023167.png)

~~~java
@SpringBootApplication
public class RestTemplateApplication {

    public static void main(String[] args) {
        SpringApplication.run(RestTemplateApplication.class, args);
    }

    // 注入RestTemplate
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
~~~

### 2.3.3 在测试类中测试

重新创建一个新的测试类：

![1589636174866](./总img/畅购前置课三/1589636174866.png)

~~~java
@SpringBootTest
@RunWith(SpringRunner.class)
public class RestTemplateTest {

    @Autowired
    private RestTemplate restTemplate;

    @Test
    public void contextLoad(){
        String url = "http://localhost:8080/user/findUsers";
        String json = restTemplate.getForObject(url, String.class);
        System.out.println(json);
    }
}
~~~



![1589636196756](./总img/畅购前置课三/1589636196756.png)





# 3 模拟服务调用



需求：根据id获取用户信息。

建库（springcloud）、建表略。

```sql
-- 使用springcloud数据库
USE springcloud;
-- ----------------------------
-- Table structure for tb_user
-- ----------------------------
CREATE TABLE `tb_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(100) DEFAULT NULL COMMENT '用户名',
  `password` varchar(100) DEFAULT NULL COMMENT '密码',
  `name` varchar(100) DEFAULT NULL COMMENT '姓名',
  `age` int(11) DEFAULT NULL COMMENT '年龄',
  `sex` int(11) DEFAULT NULL COMMENT '性别，1男，2女',
  `birthday` date DEFAULT NULL COMMENT '出生日期',
  `created` date DEFAULT NULL COMMENT '创建时间',
  `updated` date DEFAULT NULL COMMENT '更新时间',
  `note` varchar(1000) DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COMMENT='用户信息表';
-- ----------------------------
-- Records of tb_user
-- ----------------------------
INSERT INTO `tb_user` VALUES ('1', 'zhangsan', '123456', '张三', '13', '1', '2006-08-01', '2019-05-16', '2019-05-16', '好好学习');
INSERT INTO `tb_user` VALUES ('2', 'lisi', '123456', '李四', '13', '1', '2006-08-01', '2019-05-16', '2019-05-16', '天天向上');
```



## 3.1 创建服务提供方

文件放的位置

![image-20201128193646975](D:\Java笔记_Typora\我添加的img\image-20201128193646975.png)

### 3.1.1 创建工程

创建工程`<springcloud-user-provider>`添加依赖：

~~~xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.1.4.RELEASE</version>
    <relativePath/>
</parent>

<properties>
    <java.version>1.8</java.version>
</properties>

<dependencies>
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>2.0.1</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
~~~



### 3.1.2 创建pojo

在工程中创建`<com.itheima.pojo.User>`对象。

~~~java
public class User {
    
    private Integer id;
    private String username;
    private String password;
    private String name;
    private Integer age;
    private Integer sex;
    private Date birthday;
    private Date created;
    private Date updated;
    private String note;
    
    // TODO:getters/setters
}
~~~

### 3.1.3 编写Dao层

编写UserDao接口

~~~java
@Mapper
public interface UserDao {
    //这里直接用注解查询了,一般要些xml文件
    @Select("select * from tb_user where id = #{id}")
    User findById(Integer id);
}
~~~



### 3.1.4 编写Service层

编写UserService接口：

~~~java
public interface UserService {

    User findById(Integer id);
}
~~~

编写UserServiceImpl实现类：

~~~java
@Service
public class UserServiceImpl implements UserService {

    //注入dao对象
    @Autowired
    private UserDao userDao;

    /**
     * 实现功能:查询一条数据
     * @param id 查询条件
     * @return 查询的对象
     */
    @Override
    public User findById(Integer id) {
        //调用Dao层实现功能
        User user = userDao.findById(id);
        //返回参数
        return user;
    }
}
~~~



### 3.1.5 编写Controller层

在工程的目录下创建UserController类

~~~java
@RestController
@RequestMapping("/api/user")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/findById/{id}")
    public User findById(@PathVariable(value = "id") Integer id){
        return userService.findById(id);
    }
}
~~~

### 3.1.6 编写application.yml文件

编写application.yml文件。

~~~yaml
server:
    port: 9091
# DB 配置
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/springcloud?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC
    password: root
    username: root
~~~

### 3.1.7 编写启动类

~~~java
@SpringBootApplication
public class ProviderApplication {

    public static void main(String[] args) {
        SpringApplication.run(ProviderApplication.class, args);
    }
}
~~~



### 3.1.8 发布程序并访问测试

访问地址：`<http://localhost:9091/api/user/findById/1>`

![1577088487594](./总img/畅购前置课三/1577088487594.png)



## 3.2 创建服务消费方

文件放的位置

![image-20201128193817462](D:\Java笔记_Typora\我添加的img\image-20201128193817462.png)

### 3.2.1 创建工程

创建maven工程`<springcloud-user-consumer>`并且添加依赖：

~~~xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.1.4.RELEASE</version>
    <relativePath/>
</parent>

<properties>
    <java.version>1.8</java.version>
</properties>

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
~~~



### 3.2.2 编写启动类

在`<com.ithiem包下>`创建启动类并注入RestTemplate。

~~~java
@SpringBootApplication
public class ConsumerApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConsumerApplication.class, args);
    }

    // 创建要注入RestTemplate
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
~~~



### 3.2.3 编写Controller层

创建Controller类。

~~~java
@RestController
@RequestMapping("/consumer")
public class ConsumerController {
    //注入RestTemplate,在启动类中声明
    @Autowired
    private RestTemplate restTemplate;
    
	/**
     * 查询一条数据
     * @param id 条件id
     * @return json对象
     */
    @GetMapping("/findById/{id}")
    public String findById(@PathVariable(value = "id") Integer id){
        String url = "http://localhost:9091/api/user/findById/" + id;
        String json = restTemplate.getForObject(url, String.class);
        return json;
    }
}
~~~



## 3.3 调用测试

请求地址：`<http://localhost:8080/consumer/findById/1>`

![1577089053265](./总img/畅购前置课三/1577089053265.png)



## 3.4 问题总结

- 消费方调用服务方地址硬编码
- 在服务消费方中，不清楚服务提供方的状态（是否健康）
- 提供方只有一个服务，如果服务宕机，则无法访问；即便服务提供方形成集群，服务消费方还需要自己实现负载均衡



# 4 搭建Eureka注册中心

## 4.1 Eureka介绍

Eureka是Netflix开发的一个服务发现框架，本身是一个基于REST的服务，主要用于定位运行在AWS（Amazon Web Services ）域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。Spring Cloud将其集成在自己的子项目Spring Cloud Netflix中，以实现Spring Cloud的服务发现功能。

Eureka的服务发现包含两大组件：服务端发现组件（Eureka Server）和客户端发现组件（Eureka Client）。服务端发现组件也被称之为服务注册中心，主要提供了服务的注册功能，而客户端发现组件主要用于处理服务的注册与发现。

![1562666010564](./总img/畅购前置课三/1562666010564.png)

从图可以看出，当客户端服务通过注解等方式嵌入到程序的代码中运行时，客户端发现组件就会向注册中心注册自身提供的服务，并周期性地发送心跳来更新服务（默认时间为30s，如果连续三次心跳都不能够发现服务，那么Eureka就会将这个服务节点从服务注册表中移除）。与此同时，客户端发现组件还会从服务端查询当前注册的服务信息并缓存到本地，即使Eureka Server出现了问题，客户端组件也可以通过缓存中的信息调用服务节点的服务。各个服务之间会通过注册中心的注册信息以Rest方式来实现调用，并且也可以直接通过服务名进行调用。 

![1562666652758](./总img/畅购前置课三/1562666652758.png)

在Eureka的服务发现机制中，包含了3个角色：服务注册中心、服务提供方和服务消费方。

服务注册中心即Eureka Server，而服务提供者和服务消费者是Eureka Client。这里的服务提供者是指提供服务的应用，可以是Spring Boot应用，也可以是其他技术平台且遵循Eureka通信机制的应用，应用在运行时会自动的将自己提供的服务注册到Eureka Server以供其他应用发现。

服务消费者就是需要服务的应用，该服务在运行时会从服务注册中心获取服务列表，然后通过服务列表知道去何处调用其他服务。服务消费者会与服务注册中心保持心跳连接，一旦服务提供者的地址发生变更时，注册中心会通知服务消费者。

需要注意的是，Eureka服务提供者和服务消费者之间的角色是可以相互转换的，因为一个服务既可能是服务消费方，同时也可能是服务提供方。

## 4.2 Eureka入门程序

### 4.2.1 创建parent工程

我们创建一个maven工程`springcloud-microservice`，并将其`作为父工程`用来管理子工程，因为我们需要创建Eureka的注册中心以及Eureka提供方以及消费方，因此方便管理。创建好的maven工程中我们需要添加如下依赖：

~~~xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.1.4.RELEASE</version>
</parent>
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>Greenwich.SR2</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
~~~

由于是parent工程，我们可以删除src目录。

![1589638302543](./总img/畅购前置课三/1589638302543.png)



### 4.2.2 创建Eureka服务-注册中心

#### 4.2.2.1 创建工程	

创建Eureka的服务（注册中心）`eureka-server-registry`工程，需要添加如下依赖：

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>springcloud-microservice</artifactId>
        <groupId>com.itheima</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>eureka-server-registry</artifactId>

    <dependencies>
        <!--eureka服务端-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
    </dependencies>

</project>
~~~



#### 4.2.2.2 编写启动类

在启动类中添加@EnableEurekaServer注解。申明该工程为Eureka的服务。

~~~java
@SpringBootApplication
@EnableEurekaServer		// 开启eureka注册中心服务(服务端)
public class EurekaServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}
~~~



#### 4.2.2.3 编写application.yml文件

编写application.yml文件，并内容如下：

~~~yaml
server:
  port: 10086					  # 配置端口
eureka:
  instance:
    ip-address: 127.0.0.1         # 应用实例IP
  client:
    register-with-eureka: false   # 是否将自己注册到eureka中
    fetch-registry: false         # 是否从eureka中获取信息
    service-url:                  # 注册中心地址
      defaultZone: http://127.0.0.1:10086/eureka/
#      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
~~~



#### 4.2.2.4 访问注册中心

启动项目并访问，地址为： `<http://localhost:10086/>`。Eureka注册中心的控制面板如下：

![1562745976147](./总img/畅购前置课三/1562745976147.png)



### 4.2.3 创建Eureka客户端-提供方

#### 4.2.3.1 创建工程

创建服务`提供方`工程`eureka-client-provider`，添加依赖如下：

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>springcloud-microservice</artifactId>
        <groupId>com.itheima</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>eureka-client-provider</artifactId>

    <dependencies>
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>2.0.1</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!--eureka客户端-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>
    </dependencies>

</project>
~~~



#### 4.2.3.2 编写代码

将【3.1】章节`<springcloud-user-provider>`的对用户的查询代码复制到该工程

![1589639079958](./总img/畅购前置课三/1589639079958.png)

#### 4.2.3.3 编写启动类

在启动类中添加注解，表明为eureka的客户端。@EnableEurekaClient

~~~java
@SpringBootApplication
@EnableEurekaClient     // 开启eureka客户端
public class EurekaProviderApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaProviderApplication.class, args);
    }
}
~~~



#### 4.2.3.4 编写application.yml文件

编写application.yml文件，内容如下：

~~~yaml
# 配置应用基本信息和DB
server:
  port: 9091			#配置端口
spring:
  application:
    name: eureka-client-provider	#提供方(客户端)工程名
  datasource:
    driver-class-name: com.mysql.jdbc.Driver #数据库Driver
    url: jdbc:mysql://127.0.0.1:3306/springcloud?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC #连接
    username: root			#账号
    password: root 			#密码
# 配置eureka server
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka  #注册中心地址

~~~

#### 4.2.3.5 发布工程

发布工程后，eureka的控制面板如下：可以看到发布的实例，也就是说服务提供方已发布到注册中心上。

![1577092191700](./总img/畅购前置课三/1577092191700.png)



### 4.2.4 创建Eureka客户端-消费方

#### 4.2.4.1 创建工程

创建服务`消费方`工程`eureka-client-consumer`，添加依赖如下：

~~~xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
</dependencies>
~~~



#### 4.2.4.2 编写启动类

~~~java
@SpringBootApplication
@EnableEurekaClient  //开启Eureka客户端
public class EurekaConsumerApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaConsumerApplication.class, args);
    }
	
    //声明要注入的RestTemplate
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
~~~



#### 4.2.4.3 编写Controller

编写ConsumerController类。

~~~java
@RestController
@RequestMapping("/consumer")
public class ConsumerController {

    @Autowired
    private RestTemplate restTemplate;

    @GetMapping("/findById/{id}")
    public String findById(@PathVariable(value = "id") Integer id){
        String url = "http://localhost:9091/api/user/findById/" + id;
        String json = restTemplate.getForObject(url, String.class);
        return json;
    }
}

~~~



#### 4.2.4.4 配置application.yml文件

配置文件application.yml内容如下：

~~~yaml
# 配置应用基本信息
server:
  port: 8080		#端口
spring:
  application:
    name: eureka-client-consumer 	#消费者工程名
# 配置eureka server
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka   #注册中心地址
~~~



#### 4.2.4.5 发布工程

发布工程后，我们看到eureka控制面板，内容如下：

![1577097394339](./总img/畅购前置课三/1577097394339.png)

**如果出现红色内容，则为警告内容，不用关心（eureka自我保护模式）**。

### 4.2.5 调用测试

在消费方中调用，结果如下：`<http://localhost:8080/consumer/findById/1>`

![1577097548053](./总img/畅购前置课三/1577097548053.png)

### 4.2.6 Eureka其他配置（了解）

#### 4.2.6.1 注解说明

注册服务或者发现服务注解。

- ```java
  @EnableEurekaClient：基于spring-cloud-netflix。就是如果选用的注册中心是eureka，那么就推荐使用
  ```

- ```java
  @EnableDiscoveryClient：基于spring-cloud-commons。如果是其他的注册中心（consul, zookeeper），那么推荐使用
  ```

#### 4.2.6.2 自我保护机制

在注册中心中心工程中配置： 开启自我保护

~~~yaml
server:
  port: 10086
eureka:
  instance:
    hostname: 127.0.0.1
  client:
    register-with-eureka: false   # 是否将自己注册到eureka中
    fetch-registry: false         # 是否从eureka中获取信息
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka/
  server:
    enable-self-preservation: false # 是否开启自我保护机制
~~~

~~~java
系统在三种情况下会出现红色加粗的字体提示：

a.在配置上，自我保护机制关闭
RENEWALS ARE LESSER THAN THE THRESHOLD. THE SELF PRESERVATION MODE IS TURNED OFF.THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.

b.自我保护机制开启了
EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE
NOT BEING EXPIRED JUST TO BE SAFE.

c.在配置上，自我保护机制关闭了，但是一分钟内的续约数没有达到85% ， 可能发生了网络分区，会有如下提示
THE SELF PRESERVATION MODE IS TURNED OFF.THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.
~~~



#### 4.2.6.3 eureka控制台说明

![1577098462426](./总img/畅购前置课三/1577098462426.png)

~~~properties
Environment: 环境，默认为test，该参数在实际使用过程中，可以不用更改
Data center： 数据中心，使用的是默认的是 “MyOwn”
Current time：当前的系统时间
Uptime：已经运行了多少时间
Lease expiration enabled：是否启用租约过期 ，自我保护机制关闭时，该值默认是true， 自我保护机制开启之后为false。
Renews threshold： 每分钟最少续约数，Eureka Server 期望每分钟收到客户端实例续约的总数。
Renews (last min)： 最后一分钟的续约数量（不含当前，1分钟更新一次），Eureka Server 最后 1 分钟收到客户端实例续约的总数。
~~~





![1577098310789](./总img/畅购前置课三/1577098310789.png)

~~~properties
total-avail-memory : 总共可用的内存
environment : 环境名称，默认test
num-of-cpus : CPU的个数
current-memory-usage : 当前已经使用内存的百分比
server-uptime : 服务启动时间
registered-replicas : 相邻集群复制节点
unavailable-replicas ：不可用的集群复制节点，如何确定不可用？ 主要是server1 向 server2和server3发送接口查询自身的注册信息，
如果查询不到，则默认为不可用，也就是说如果Eureka Server自身不作为客户端注册到上面去，则相邻节点都会显示为不可用。
available-replicas ：可用的相邻集群复制节点
~~~



#### 4.2.6.4 服务续约

服务注册完成以后，服务`提供者会`维持一个`心跳`，保存服务处于存在状态。这个称之为服务续约(renew).服务超过90秒没有发生心跳，Eureka Server会将服务从列表移除。我们可以在eureka的客户端配置如下内容：

~~~yaml
#向Eureka服务中心注册服务
eureka:
  instance:
  	# 租约到期，服务时效时间，默认值90秒
    lease-expiration-duration-in-seconds: 90 
    # 租约续约间隔时间，默认30秒
    lease-renewal-interval-in-seconds: 30 
~~~



#### 4.2.6.5 失效剔除

服务中心每隔一段时间(默认60秒)将清单中没有续约的服务剔除。通过`eviction-interval-timer-in-ms`配置可以对其进行修改，单位是秒。我们可以在eureka客户端程序中配置如下内容：

~~~yaml
eureka:
  instance:
  	# 超过180秒没有续约的服务将被剔除
  	eviction-interval-timer-in-ms: 180
~~~



# 5 使用Ribbon实现负载均衡

## 5.1 Ribbon介绍

在分布式架构中，服务器端负载均衡通常是由Nginx实现分发请求的，而客户端的同一个实例部署在多个应用上时，也需要实现负载均衡。那么Spring Cloud中是否提供了这种负载均衡的功能呢？答案是肯定的。我们可以通过Spring Cloud中的Ribbon来实现此功能 

Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。Spring Cloud Ribbon虽然只是一个工具类框架，它不像服务注册中心、配置中心、API网关那样需要独立部署，但是它几乎存在于每一个Spring Cloud构建的微服务和基础设施中。因为微服务间的调用，API网关的请求转发等内容，实际上都是通过Ribbon来实现的，包括后续我们将要介绍的Feign，它也是基于Ribbon实现的工具。所以，对Spring Cloud Ribbon的理解和使用，对于我们使用Spring Cloud来构建微服务非常重要。

## 5.2 入门程序

场景说明：

- 开启多个（本次两个）服务提供方；
- 启动消费方进行调用测试

### 5.2.1 启动两个提供方

#### 5.2.1.1 修改端口

**修改提供方**配置文件端口

![1606537303981](./总img/畅购前置课三/1606537303981.png)

#### 5.2.1.2 编辑启动应用配置

- 修改发布的应用名称
- 修改发布的应用端口：-Dport=9091

![1577109781948](./总img/畅购前置课三/1577109781948.png)

#### 5.2.1.3 复制一份新应用

- 复制一份新的应用

- 修改端口以及名称

![1577109874139](./总img/畅购前置课三/1577109874139.png)



#### 5.2.1.4 通过Eureka查看

启动服务，通过eureka控制面板查看服务

![1577110015893](./总img/畅购前置课三/1577110015893.png)



### 5.3.1 修改消费方

#### 5.3.1.1 添加@LoadBalanced注解

在启动类的注入RestTemplate方法上添加客户端负载均衡的注解。**@LoadBalanced**

![1562773626117](./总img/畅购前置课三/1562773626117.png)



#### 5.3.1.2 修改ConsumerController

修改ConsumerController代码：

![1577110743958](./总img/畅购前置课三/1577110743958.png)

~~~java
@RestController
@RequestMapping("/consumer")
public class ConsumerController {

    @Autowired
    private RestTemplate restTemplate;

    @GetMapping("/findById/{id}")
    public String findById(@PathVariable(value = "id") Integer id){
//        String url = "http://localhost:9091/api/user/findById/" + id;
        // 通过服务名称调用
        String url = "http://eureka-client-provider/api/user/findById/" + id;
        String json = restTemplate.getForObject(url, String.class);
        return json;
    }

}
~~~

#### 5.3.1.3 启动消费方

略。

### 5.4.1 访问测试

- 我们可以在提供方的controller中打印port：

  ![1577110894939](./总img/畅购前置课三/1577110894939.png)

- 刷新四次，console控制查看结果：（分别访问两次，默认走的负载均衡的策略为轮询）

  ![1562776140067](./总img/畅购前置课三/1562776140067.png)

### 5.5.1 坑

使用ribbon实现负载均衡的时候，服务名称不能用下划线。

![1562776420306](./总img/畅购前置课三/1562776420306.png)



## 5.3 Ribbon负载均衡策略

### 5.3.1 默认策略

Ribbon默认的负载均衡策略是轮询。

修改`消费值`配置文件

~~~yaml
# 修改服务地址轮询策略，默认是轮询，配置之后变随机
# 服务消费方配置
eureka-client-provider: # 服务(提供者)名称
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
~~~



### 5.3.2 Ribbon支持的轮询算法

![1562777949257](./总img/畅购前置课三/1562777949257.png)

| RoundRobinRule            | 轮询规则（默认方法）                                         |
| ------------------------- | ------------------------------------------------------------ |
| **RandomRule**            | **随机**                                                     |
| AvailabilityFilteringRule | 先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，还有并发的连接数量超过阈值的服务，然后对剩余的服务进行轮询 |
| WeightedResponseTimeRule  | 根据平均响应时间计算服务的权重。统计信息不足时会按照轮询，统计信息足够会按照响应的时间选择服务 |
| RetryRule                 | 正常时按照轮询选择服务，若过程中有服务出现故障，在轮询一定次数后依然故障，则会跳过故障的服务继续轮询 |
| BestAvailableRule         | 先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务 |
| ZoneAvoidanceRule         | 默认规则，符合判断server所在的区域的性能和server的可用性选择服务 |



# 5 使用Hystrix熔断器

## 5.1 Hystrix介绍

![1562779660697](./总img/畅购前置课三/1562779660697.png)

- Hystrix，英文意思是豪猪，全身是刺，刺是一种保护机制。Hystrix也是Netflix公司的一款组件。
- Hystrix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库、防止出现级联失败也就是雪崩效应。

## 5.2 雪崩效应

- 微服务中，一个请求可能需要多个微服务接口才能实现，会形成复杂的调用链路。
- 如果某服务出现异常，请求阻塞，用户得不到响应，容器中线程不会释放，于是越来越多用户请求堆积，越来越多线程阻塞。
- 单服务器支持线程和并发数有限，请求如果一直阻塞，会导致服务器资源耗尽，从而导致所有其他服务都不可用，从而形成雪崩效应。

![1562779475671](./总img/畅购前置课三/1562779475671.png)

A为服务提供者，B为A的服务调用者，C和D是B的服务调用者。随着时间的推移，当A的不可用引起B的不可用，并将不可用逐渐放大到C和D时，整个服务就崩溃了。 

## 5.3 熔断器原理

### 5.3.1 空气开关

为了解决服务级联失败这种问题，在分布式架构中产生了熔断器等一系列的服务保护机制。分布式架构中的熔断器，就类似于我们生活中的空气开关，当电路发生短路等情况时，空气开关会立刻断开电流，以防止用电火灾的发生。

![1562779688709](./总img/畅购前置课三/1562779688709.png)



### 5.3.2 熔断器

在Spring Cloud中，Spring Cloud Hystrix就是用来实现断路器、线程隔离等服务保护功能的。Spring Cloud Hystrix是基于Netflix的开源框架Hystrix实现的，该框架的使用目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。

#### 5.3.2.1 熔断器状态

与空气开关不能自动重新打开有所不同的是，断路器是可以实现弹性容错的，在一定条件下它能够自动打开和关闭，其使用时主要有三种状态。

![1562921641664](./总img/畅购前置课三/1562921641664.png)

- Closed：关闭状态（**前健康状况高于设定阈值**），所有请求正常访问
- Open：打开状态（**当前健康状况低于设定阈值**），所有请求静止通过，如果设置了fallback方法，则进入该流程
- Half Open：半开状态（**当断路器开关处于打开状态，经过一段时间后，断路器会自动进入半开状态。这时断路器只允许一个请求通过；当该请求调用成功时，断路器恢复到关闭状态；若该请求失败，断路器继续保持打开状态，接下来的请求会被禁止通过**）



断路器的开关由关闭到打开的状态是通过当前服务健康状况（服务的健康状况=请求失败数/请求总数）和设定阈值（默认为5秒内的20次故障）比较决定的。当断路器开关关闭时，请求被允许通过断路器，如果当前健康状况高于设定阈值，开关继续保持关闭；如果当前健康状况低于设定阈值，开关则切换为打开状态。当断路器开关打开时，请求被禁止通过；如果设置了fallback方法，则会进入fallback的流程。当断路器开关处于打开状态，经过一段时间后，断路器会自动进入半开状态，这时断路器只允许一个请求通过；当该请求调用成功时，断路器恢复到关闭状态；若该请求失败，断路器继续保持打开状态，接下来的请求会被禁止通过。

#### 5.3.2.2 服务降级方法

pring Cloud Hystrix能保证服务调用者在调用异常服务时快速的返回结果，避免大量的同步等待，这是通过HystrixCommand的fallback方法实现的。

**熔断器的核心：线程隔离和服务降级。**

- 线程隔离：是指Hystrix为每个依赖服务调用一个小的线程池，如果线程池用尽，调用立即被拒绝，默认不采用排队。
- 服务降级(兜底方法)：优先保证核心服务，而非核心服务不可用或弱可用。触发Hystrix服务降级的情况：线程池已满、请求超时。

![1562779998489](./总img/畅购前置课三/1562779998489.png)

虽然A服务仍然不可用，但采用fallback的方式可以给用户一个友好的提示结果，这样就避免了其他服务的崩溃问题。 

## 5.4 入门程序

目标：服务提供者的服务出现了故障，服务消费者快速失败给用户友好提示。体验服务降级好处。

### 5.4.1 添加依赖

在服务消费方工程（eureka-client-consumer）添加hystrix依赖

~~~xml
<!--熔断器-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
</dependency>
~~~



### 5.4.2 开启熔断器注解

在消费方工程的`启动类中`添加开启熔断器的注解：**@EnableCircuitBreaker**；

或者直接添加一个`组合注解`：**@SpringCloudApplication**。

![1562917251060](./总img/畅购前置课三/1562917251060.png)

启动类上

```java
package com.itheima;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.SpringCloudApplication;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

/**
 * @Author: wzw
 * @Date: 2020/11/28 20:24
 * @version: 1.8
 */
@SpringCloudApplication //修改点:添加熔断器的组合注解
public class EurekaConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaConsumerApplication.class,args);
    }

    //配置要注入的RestTemplate
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}

```



### 5.4.3 编写服务降级方法

<!--注意：因为熔断的降级逻辑方法跟正常逻辑方法一样，必须保证相同的参数列表和返回值相同-->

#### 5.4.3.1 作用在方法上

在消费方工程的controller中，添加服务降级方法：

![1577111451093](./总img/畅购前置课三/1577111451093.png)

~~~java
@RestController
@RequestMapping("/consumer")
public class ConsumerController {

    @Autowired
    private RestTemplate restTemplate;


    @GetMapping("/findById/{id}")
    @HystrixCommand(fallbackMethod = "findByIdFallBack")
    public String findById(@PathVariable(value = "id") Integer id){
//        String url = "http://localhost:9091/api/user/findById/" + id;
        // 直接调用服务名称
        String url = "http://eureka-client-provider/api/user/findById/" + id;
        String json = restTemplate.getForObject(url, String.class);
        return json;
    }

    // 服务降级方法
    public String findByIdFallBack(@PathVariable(value = "id") Integer id){
        return "对不起，服务器睡着了。。。";
    }

}
~~~



**测试：我们服务提供方工程停掉**。

![1589641016610](./总img/畅购前置课三/1589641016610.png)

#### 5.4.3.2 作用在类上

- 刚才把fallback写在了某个业务方法上，如果方法很多，可以将FallBack配置加在类上，实现默认FallBack
- @DefaultProperties(defaultFallback=”defaultFallBack“)，在类上，指明统一的失败降级方法

![1577111843951](./总img/畅购前置课三/1577111843951.png)

~~~java
@RestController
@RequestMapping("/consumer")
@DefaultProperties(defaultFallback = "defaultFallBackMethod")
public class ConsumerController {

    @Autowired
    private RestTemplate restTemplate;


    @GetMapping("/findById/{id}")
//    @HystrixCommand(fallbackMethod = "findByIdFallBack")
    @HystrixCommand
    public String findById(@PathVariable(value = "id") Integer id){
//        String url = "http://localhost:9091/api/user/findById/" + id;
        // 直接调用服务名称
        String url = "http://eureka-client-provider/api/user/findById/" + id;
        String json = restTemplate.getForObject(url, String.class);
        return json;
    }

    // 服务降级方法
    public String findByIdFallBack(@PathVariable(value = "id") Integer id){
        return "对不起，服务器睡着了。。。";
    }

    // 服务降级方法：作用在类上。针对所有方法。
    public String defaultFallBackMethod(){
        return "统一回复：系统繁忙。。。";
    }

}
~~~



## 5.5 熔断策略（了解）

### 5.5.1 常见熔断策略

常见熔断策略配置：

- 熔断后休眠时间：sleepWindowInMilliseconds

- 熔断触发最小请求次数：requestVolumeThreshold

- 熔断触发错误比例阈值：errorThresholdPercentage

- 熔断超时时间：timeoutInMilliseconds

   

   信号量隔离：strategy: SEMAPHORE	

  - 与调用线程相同 

  - 无线程切换，开销低 

  - 异步：不支持 

  - 并发支持：



### 5.5.2 配置熔断策略

在服务**消费方工程【eureka-client-consumer】**配置如下内容：

~~~yaml
# 配置熔断策略：
hystrix:
  command:
    default:
      circuitBreaker:
        # 触发熔断错误比例阈值，默认值50%
        errorThresholdPercentage: 50
        # 熔断后休眠时长，默认值5秒
        sleepWindowInMilliseconds: 5000
        # 熔断触发最小请求次数，默认值是20
        requestVolumeThreshold: 6
      execution:
        isolation:
          thread:
            # 熔断超时设置，默认为1秒
            timeoutInMilliseconds: 2000
~~~

### 5.5.3 测试熔断超时时间

在服务提供方，让线程休眠超过2秒中（例如休息5秒中），这个时候会走Fallback方法（因为在熔断策略配置当中，我们配置了熔断超时时间为2秒中，一旦超过2秒，则认为被调用的服务挂了，因此走Fallback【兜底】方法）。

![1577112257654](./总img/畅购前置课三/1577112257654.png)

````java
package com.itheima.controller;

import com.itheima.pojo.User;
import com.itheima.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @Author: wzw
 * @Date: 2020/11/28 18:13
 * @version: 1.8
 */
@RestController
@RequestMapping("/api/user")
public class UserController {

    @Autowired
    private UserService userService;

    @Value(value = "${server.port}")
    private String port;

    @GetMapping("/findById/{id}")
    public User findById(@PathVariable(value = "id")Integer id){
        //==============测试宕机5秒==============
        try {
            Thread.sleep(5000);
        } catch (Exception e) {
            e.printStackTrace();
        }
        //==============测试宕机5秒==============
        System.out.println("port"+port);
        return userService.findById(id);
    }
}
````



### 5.5.4 测试熔断错误比例

- **把提供方线程休眠的代码删除**
- 在**服务消费方**编写抛出异常的代码

![1577112758356](./总img/畅购前置课三/1577112758356.png)



- 如何测试：

  访问`<http://localhost:8080/consumer/findById/2>`	上，那么这个时候访问id=1的用户信息无法访问到，需要等待熔断休眠后（默认5秒），就可以正常访问id=1的用户了。

  

# 6 RPC与HTTP区别（了解）

~~~properties
1、传输协议
RPC，可以基于TCP协议，也可以基于HTTP协议
HTTP，基于HTTP协议

2、传输效率
RPC，使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2协议，也可以很好的减少报文的体积，提高传输效率
HTTP，如果是基于HTTP1.1的协议，请求中会包含很多无用的内容，如果是基于HTTP2.0，那么简单的封装一下是可以作为一个RPC来使用的，这时标准RPC框架更多的是服务治理

3、性能消耗，主要在于序列化和反序列化的耗时
RPC，可以基于thrift实现高效的二进制传输
HTTP，大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能   
WebService：数据的传输xml

4、负载均衡
RPC，基本都自带了负载均衡策略
HTTP，需要配置Nginx（10w），HAProxy、LVS（阿里2000年）来实现    硬件：F5、Array

5、服务治理
RPC，能做到自动通知，不影响上游（MQ）
HTTP，需要事先通知，修改Nginx/HAProxy配置

总结：
RPC主要用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用、支付接口调用等。
~~~















