`

# 面向对象 

### 记忆点：指挥+代码复用

与面向过程相比，面向对象是开发者指挥对象(服务提供者)去完成程序，比如灯类Ligth，当需要去操作灯的时候，只需要new Light(),拿到灯的实例，就可以去开灯on(),关灯off(),Light对象还拥有自身的属性比如材料等。

`封装 `作为对象的创建者，初衷是让客户端开发者能更好地指挥对象去完成需要的操作，如果对象的内容能够随意被更改，就会出现一些莫名其妙的问题，这是创建者不希望看到的，因此对象应该是一个被隐藏的具体实现，而不能暴露在所有的开发者面前，所谓的封装就是解决这个问题的。

`继承` 如果有一个对象和已存在的对象有着高度的相似，这时候不得不去创建一个新的类。比如正方形长方形圆形都是几何形状，那这时候就可以基于几何形去创建对应的形状对象，新的对象能够包含几何形的公共特征，又不会破坏父类的内部结构，这就是继承的概念，java中只支持单继承(父类只能有一个)。

`多态` 使用对象时，通常不需要去考虑使用的具体类型，这一点在对象作为参数的时候表现的尤为明显，所以多态的出现正好可以解决这一痛点。但多态势必会产生上下转型的困难，这也是多态的缺点之一。

多态的前提：继承或者实现的关系+父类引用指向子类对象 

### 接口

##### 记忆点：规范

也是class文件，就是为对象的使用提供一套**规范**，比如JDBC如果数据库产商在没有接口的情况下，都去编写自己的操作数据库实现类，就会造成很多的乱象，比如方法名千奇百怪，这对开发者来说是很麻烦的。

接口的方法实际上是public abstract  void 方法名()，当通常都省略权限修饰符和abstract关键字，因为接口的方法既然是规范，它必定是公开且无实现的。

**interface接口和abstract抽象类的区别：**

相同：都不能通过new来实例化，如果继承/实现，必须实现抽象方法。

不同：抽象类拥有构造方法，给子类使用，接口中没有

            接口的成员变量必须是常量(final修饰)，而抽象类可以任意类型
    
            实现接口必须实现所有方法，而抽象类可以选择性实现，但该类还是抽象类
    
            接口没有静态代码块和静态方法(jdk1.9才有)，抽象类有
    
            抽象类单继承，而接口可以多实现

**当关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。**

# Java中的集合

## Conllection单列集合

底层基于数组实现，解决数组扩容复杂等问题。

常用结构：Conllection父类接口

List接口 三有集合:有索引,有序,有重复

```java
                        -----ArrayList  基于数组 初始容量为10 add()时扩容数组
                        -----LinkedList 基于链表
                        -----Vector     线程安全
```
Set接口  三无集合:无索引,无序,无重复

```java
                         -----HashSet-----LinkedHashSet
                         -----TreeSet
```

![01_单列集合的继承体系](D:\Java笔记_Typora\我添加的img\01_单列集合的继承体系.png)

## Map双列集合

### 一、HashMap的底层实现



`数据结构: `数组+链表+红黑树

`时间复杂度:`O1 总结:因为拿的是数组高效查询,并根据键值找到哈希桶的位置

`初始化:`会初始化16个桶,但初始化的条件是put第一个数,因为他是懒加载的形式

`扩容条件:`当负载因子到0.75的时候会进行2倍的扩容

`怎么扩容:`原来的数据会根据**高低位链**的划分，低位链不变,高位链会根据(原索引+原长度)划分到扩容区中

`插入的方法:`采用的是尾插法

HashMap主要做了两件事,分别是`扰乱函数`和`路由寻址`

`扰乱函数`:在底层是key的hashCode值,主要是用高16位异或低16位,算出地址值,`目的`是为了然地址值更加散列

而算出的数和HanhMap中的值相同,就会引起`哈希冲突`,一般我们用`拉链法`解决这个问题

`路由寻址:`是通过(n-1)&hash来获取的地址值,n是桶的长度,hash就扰乱函数算出来的地址

`树化:`当链表的数量达到8的时候或者容量到64的时候就回树化,`链表会转为红黑树`

`退化:`当链表的数量从8到6了以后就会产生退化,`红黑树转回链表`

因为是

```java
//哈希桶
[<key,value>,<key,value>-><key,value>-><>(链表),<>,<>,<>...<>,<>,<>,<>]//初始长度16
```

### 二、HashMap的相关类

#### 与HashMap的区别 **记忆点：数据结构+线程安全**问题

Hashtable：线程安全类(JDK1.0),方法全都加上了syncronized同步锁，**锁住整个哈希桶**，它调用equlas()判断hash值存入哈希桶，因此不能存入null键和值。

CurrentHashMap：局部同步+CAS自旋实现线程安全，锁住哈希桶一个index，桶长度是固定的，存相同index和扩容的时候不是接链表而是往后面挂数组。

![04_jdk1.8的HashMap](D:\Java笔记_Typora\我添加的img\04_jdk1.8的HashMap.png)



# 多线程

### Thread多线程

线程并发基本概念：多个线程相互抢占资源。

#### **一、线程创建方式**:

一、实现Runable接口重写run()，并new Thread(Runable)

二、创建类继承Thread，重写run()，创建该类的对象既可

有些地方开线程会new Tread()并存入ArrayList，遍历集合同时开线程

##### Runnable和Callable区别(记忆点：能否返回执行结果)

都是线程任务，但Callable重写call()，如果提交线程池会得到Future的返回值，通过FutureTask.get()可以返回执行结果。

#### 二、线程池

##### 创建方法:

使用线程类Executors.newFixedThread()得到ExectorService线程池对象，需要提交线程可以直接使用

ExectorService的submit(Runable)，但不推荐因为有可能出现**OOM**因此可以使用

**new ThreadPoolExecutor**(1,2,3,4,5)
参数分别是：线程核心数、最大执行数，超过核心数等待时间、
时间单位、阻塞队列(等待的线程会进去，指定长度)
时间单位格式是TimeUnit.H/M/S
阻塞队列格式是new ArrayBlockingQueue<>(队列长度)

#### 三、线程安全

线程安全：多个线程对同一个数据进行访问(取值修改等操作)，从而产生的数据无法达到期望值的一种安全问题。

##### JMM Java内存模型

```java
线程会到本地内存/工作内存中拿自己需要操作的数据，而本地内存是从主存中拿到数据并保存为副本的。
线程--->本地内存--->主存
    
public class Account{public static int money =10000;} 
//创建两个线程 线程一方法中while(money=10000){},线程二方法中 sleep一下(为了让线程一先拿到主存中的值)并修改money，这是会发现线程一一直在执行，数据此时没有可见性。

//可见性 线程并不是直接到主存中拿数据的，中间隔了个本地内存，相当于有个带话人一样
    
//原子性 数据的不可分割，典型的比如i++，通过java p可以看到他的操作是分为三步的，这样很容易被抢走执行权，就代表他没有原子性。
//有序性 改变执行的顺序也不影响执行结果 指令重排序执行效率会变高   
```

##### volatile关键字

volatile修饰的数据，具有可见性，禁止了指令重排序，但不具有原子性，比如循环i++，并同时开几个线程，会发现结果并不正确 

##### Synchronized关键字

同步锁

基本概念:通过类对象进行加锁，相同锁的线程会相互等待，如果是加在方法上，默认使用当前类实例对象(静态方法使用类的class)，加锁发生异常会自动释放锁，而**lock**锁则不会自动释放。

##### 底层原理：跟jvm指令和monitor有关(硬件方面还跟内存屏障有关)

当使用synchronized关键字，底层编译的jvm指令中，会有monitorenter和monitorexit两个指令

比如说线程一先拿到了该对象的锁，对象的monitor计数器就会从0变成1，线程二还想进来加锁发现计数器不是0就会进入阻塞状态，monitor支持重入加锁比如

```java
synchronized(){--->线程一拿到锁 计数器+1
    //代码 清空工作内存 拿到主存的数据
    synchronized(){----计数器+1
        //代码执行
        //代码结束执行monitorexit释放锁 计数器-1
    }
        //代码结束执行monitorexit释放锁 计数器-1=0
}
```



##### 悲观锁

synchronized是一种**悲观锁**/独占锁(被害妄想症患者)，无论如何都会加锁防止其他线程的迫害。

Lock锁也可以实现悲观的线程安全，一般使用其实现类ReentrantLock，加锁lock

(),解锁unlock(),发送异常会导致没有释放锁产生死锁的问题。



##### 乐观锁

JDK1.5后新增并发包java.util.concurrent.*，其中的类使用**CAS**算法实现了同步线程安全，这叫**乐观锁**。

```java
比如 AtomicInteger num =new Atomicinteger(n) //原子数n
```

CAS(compare and set)是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

**CAS实现原理**(原子类AtomicInteger源码为例)：

 ```java
//当调用这个方法
public final int getAndAdd(int delta) { //相当于i++
        return unsafe.getAndAddInt(this, valueOffset, delta);
    }

 public final int getAndAddInt(Object o, long Offset, int delta) {
     int v;
        do {  //o  内存值
            v = this.getIntVolatile(o, Offset);//拿到旧值v
            //v + delta 新值
        } while(!this.compareAndSwapInt(o, Offset, v, v + delta));//CAS(compare and set)

        return v;
    }

线程一会先获取内存值1，当做旧值，进行+操作，得到新值，再重新获取内存值2(有可能被抢执行权)，把这两个内存值进行比较，相同就结束循环，不同就重复上述操作。
    这个循环的操作就叫做自旋
 ```

**ABA**：CAS出现的问题

两个线程操作数据会发生数据的无意义操作，比如线程二对数据进行了+1-1的操作，线程一发现数据没变，就会进行修改，这时可以通过加版本号的方式来解决这个问题

**相关并发包**

CountDownLatch：可以让线程等待其他线程完成(阻塞)再进行

CyclicBarrier：当多条线程到达屏障点，可以触发新的线程任务

Semaphore:  获取到许可证，就执行否则就等待

Exchanger：线程之间交换数据

##### 死锁

前提：同步的嵌套(不一样的锁) 线程一拿着锁A等锁B，线程二拿着锁B等锁A

```java
synchronized(A){                           
    synchronized(B){                                       
      //线程一                                  
    }                                  
}
synchronized(B){                           
    synchronized(A){                                       
      //线程二                                  
    }                                  
}      
```

# JVM







## Servlet

# MySQL数据库

采用的是B+树的结构

常用的有两个数据引擎:

* InnoDB默认开启 的数据引擎
  * 支持事务
  * 支持分布式事务规范(XA)
  * 保存点(用于恢复固定时间点的数据)
    * 比如:9点有个保存点,现在数据已经是10点的更新了很多次,但我们还能恢复到9点的数据
* MyISAM 需要在创建表的时候需要在engine属性上指定
  * 不支持事务(查询的时候才会用)

## sql语句

### CRUD

C ==> 增加

R ==> 查询

U ==> 修改

D ==> 删除

### Insert into 增加

Insert into 表名(要添加的字段) values(要添加的内容)

例子: insert into user(name,sex) values("王子威",18)

### delete 删除

### select 查询

### updata 修改

limit排序

## 索引

## 优化

### 简单优化



## 事务

### 概念

一次操作,要么全部成功,要么全部失败(一个业务出现问题,整个数据都回滚)

### 	特征:ACID

A:原子性:保证程序要不成功,要不失败

C:一致性:更像目的,让其提交前后的数据一致

I : 隔离性:是指在并发时候的状态时,理论上相互不干扰,独立

D:持久性:一旦提交事务成功,就是写进磁盘中

### 并发问题(脏读,幻读,不可重复读)

1.脏读

* 提交未成功
* 但另一个程序就已经读取到了对应的数据进行了相关操作(严重)

2.幻读

* 提交成功,
* 受到insert或delete的干扰
* 一个事务中多次读取的数据不一致
* 原因时受到其他事务影响

3.不可重复读

* 提交成功
* 受到update的干扰
* 一个事务中多次读取的数据不一致
* 原因时受到其他事务影响

### 事务隔离级别

1.Read uncommitted

* 读未提交
* 最不安全,但性能最强
* 有脏读(唯一有脏读的)

2.read committed

* 读已提交
* Oracle默认使用这种
* 无脏读

3.repeatable read

* 重复读
* MySql默认使用这种
* 五脏读

4.Serializable

* 串行化
* 最安全
* 性能最弱

### JDBC事务[一个数据库]

开启事务:beginTransaction

例如:try{提交事务:commit}cacth{ 回滚事务: rollback }

### Mybatis事务[一个数据库]

要sqlSession提交/回滚事务操作



### Spring事务[一个数据库]

个人理解:一般都是有个模板,先主从事务管理器,接着配置事务的通知,开启事务的驱动,在配置事务的切入点表达式,但是一般都是用注解+xml配置,应为这样只需要在需要事务的方法和类上加入事务注解即可

利用AOP的特性,增强方法

在方法或类上加上事务注解:@Transactional



## 分布式事务[多个数据库]

### 我们写的订单模块就是多服务多数据源的案例

* 创建订单:order服务---->changgou_order数据库
* 扣减库存: goods服务 -->changgou_goods数据库
* 增加积分:user服务----->changgou_user数据库

### 应用场景

1.单服务多数据源

2.多服务单数据源

3.多服务多数据源

![image-20201231104735888](D:\Java笔记_Typora\我添加的img\image-20201231104735888.png)

### CAP定理(布鲁尔定理)

C==>一致性:全部数据都要修改

A==>可用性:只要受到用户的请求,服务器就必须给出响应

P==> 分区容错性(地域的分区):分布在不同的子网络中,比如:一个中国,一个台美国

注意:P总是会成立,但A和C无法同时做到,所以只会两两成立

![CAP](D:\Java笔记_Typora\我添加的img\CAP.png)

### 分布式事务的解决方案

#### 1.两段协议提交(2PC)基于XA协议

* 第一阶段:准备工作 首先可开启事务 判断该数据资源是否正常工作
* 第二阶段:提交/回滚
  * 扣钱成功,收钱成功=>提交事务
  * 扣钱或收钱失败  ==>回滚事务
* 软件MyCat分库分表中间组件

#### 2.补偿事务TCC

#### 3.本地消息表(异步确保)

#### 4.MQ事务消息

#### 5.Seata 2PC->改进[我们这里用]



# SSM框架

## Mybatis

## Spring

是一个轻量级框架,IOC和AOP作为核心

* IOC实现反转控制,也就是工厂解耦,是指把创建对象控制权交给框架做[举例:饭店]
  * 如果service里需要dao,说明service依赖于dao:dao就是一个依赖项
  * 需要什么对象我们就去new什么对象==>偶合性太强,
  * 现在需要什么对象,就去工厂BeanFactory里获取什么对象==>耦合性降低了
  * 总结:由主动变被动
  * 目的:解耦

* AOP面向切面是基于动态代理实现预编译方式,主要内容是切面Aspect.而切面=通知+切入点,最后还要织入也就时生成代理对象的过程,配置方式也是三种(纯xml,注解+xml,纯注解),
  * 目的:可以让我们最相关功能进行增强

### 一.IOC控制反转(底层工厂解耦)

#### IOC实现反转控制,也就是工厂解耦,是指把创建对象控制权交给框架做[举例:饭店]

* 如果service里需要dao,说明service依赖于dao:dao就是一个依赖项
* 需要什么对象我们就去new什么对象==>偶合性太强,
* 现在需要什么对象,就去工厂BeanFactory里获取什么对象==>耦合性降低了
* 目的:让我们可以更加专注于上层代码的应用,业务成的实现

#### Bean的生命周期

* 单例
  * 容器创建时创建
  * 容器关闭时销毁
* 多例
  * 获取bean对象时创建
  * jvm垃圾回收

#### 注入的常见的三种方式

* set方法注入[常用]
  * 要求:依赖项要有set方法
* 构造方法注入
  * 要求:需要有构造方法,构造方法中每个参数就是一个依赖
*  p名称空间注入
  * 本质还是set注入
  * 需要写p路径
* 配置:在xml的bean中配置即可

### 二.AOP面向切面(底层动态代理)

1.自己的话:

* AOP面向切面是基于动态代理实现预编译方式,主要内容是切面Aspect.而切面=通知+切入点,最后还要织入也就时生成代理对象的过程,配置方式也是三种(纯xml,注解+xml,纯注解)
* 这样就要解释通知:(增强的内容)
  * 前置通知
  * 后置通知
  * 异常通知
  * 最终通知
  * 环绕通知(注意:环绕通知包括以上4个通知)
* 切入点(要增强的方法)
  * execution(表达式)
  * 表达式的格式(说白了就是我们定义方法的格式)
    * 修饰符(可以省略)
    * 返回值类型(支持通配符)
    * 包名.类名(支持通配符,且一个点表示子级;两个点表示后代)
    * 方法名(支持通配符)
    * 形参列(支持通配符,且两个点表示任意参数)
* 织入
  * 生成代理对象的过程
  * 把切入点和通知进行结合
* 我们使用的Spring的AOP
  * 需要做的
    * 编写目标对象
    * 编写通知
    * 配置切面
  * Spring帮我们做的
    * 根据我们配置的切面,生成代理对象,放到容器里



## Springmvc

### DispatcherServlet

* 名字:前端控制器/核心控制器
* 指派别器做事,自己不做事(老板)
* 步骤
  * 接收用户请求
  * 调用HandlerMapping处理器的映射器
  * 调用HandlerAdapter来调用处理器
  * 调用ViewResolver方法,传递页面路径,找视图(未填充)
  * 调用View视图如安然

### HandlerMapping

* 名字:处理器的映射器
* 职责:根据请求路径,查找到对应的处理器(Contrller方法)
* 用来找Contorller层
  * Controller里的每个方法:Handler
* 返回:Handler以及拦截器

### HandlerAdapter

* 名字:处理器的适配器
* 职责:用于调用处理器方法,得到处理并返回结果(调业务)
* 因为Controller有可能是
  * 自定义接口或者第三方的接口
  * 可以通过这个调用
* 返回:ModelAndView

### ViewResolver

* 名字:视图解析器
* 职责:根据路径找到真实的页面
  * 需要传递页面路径
  * 返回真实页面

### View

* 名字:视图
* 作用:渲染视图

## SpringSecurity

* 是什么

Spring Security 是Spring的企业应用系统访问控制的安全框架(权限框架),它充分的利用了IOC和AOP功能,

* 做什么

简化了认证和授权功能,可以自己生成一个简陋的登录页面

* 怎么做[写的项目功能]
  * 用到权限五张表(我写的功能用到七张表)
    * 权限五张表(RBAC)
      * 用户表
      * 用户角色表(中间表)
      * 角色表
      * 角色权限表(中间表)
      * 权限表(授权表)
    * 角色菜单表(中间表)
    * 菜单表(哪个权限该加载的数据页面)
  * 步骤
    * 委托代理过滤器
    * 拦截请求
    * 一系列权限过滤器
    * 请求配置,完成认证功能
    * 认证管理器配置
* 遇到的问题
  * 自定义登录页面
    * 过于简单,需要自己写一个
    * 禁用csrf,不然没有权限
  * 匿名访问资源
    * security="none" 路径
  * 密码加密
    * 用bcryt随机盐加密
  * 密码需要从数据库查询验证
    * 自定义认证了,实现接口UserServiceDetail
    * 根据用户名查询用户表是否存在
    * 不存在,直接返回null
    * 存在,则获取数据库密码
    * 为当前用户授权
    * 将用户名,密码,权限列表返回给框架
  * 密码需要加载保证安全
  * 基于配置文件权限控制(主要用于页面)
  * 基于注解方式权限控制(主要用于Controller层)
    * 开启扫描器
    * 开启权限注解
    * 加一个@PreAuthorize(表达式('权限'));

# 微服务框架

## SpringBoot

简述：为了简化开发，减少配置文件使用默认配置(**构建一切**)

### 自动装配原理

run的时候，springboot会去加载**spring.factories**里所声明需要配置的框架等，然后加载他们的配置类，配置类中声明了所需要的默认配置，以及根据条件注解new生成对应的bean注册到ioc容器中。

以mybatis-spring-boot-starter为例

首先@SpringBootApplication里有三个重要的元注解，其中@EnableAutoConfiguration注解就是自动配置

@EnableAutoConfiguration(源码)

```java
@Import(AutoConfigurationImportSelector.class)//导入配置文件
AutoConfigurationImportSelector中selectImports()的getAutoConfigurationEntry()
getAutoConfigurationEntry()里的getCandidateConfigurations()//配置spring.factories

    # Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration
    每个对应的配置文件会去new并注册bean进ioc容器 
    比如
  @Bean
  @ConditionalOnMissingBean
  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();}
```

## SpringCloud

### Spring Cloud Gateway  网关组件

* 三个特点
  * `路由`
    * 将请求转发到其他服务上
  * `断言`
    * 匹配请求的URL规则
  * `过滤器`
    * 对请求可以做限制或处理
* 应用的场景
  * 限流
  * 认证
  * 鉴权
  * 记录日记等等

在项目中我们一开始是要网关的过滤器来对令牌进行拦截,然后就可以对它的内容进行认证和鉴权,因为我们的令牌用的是JWT的规范来生成的所以在网关中要对应的方法解析令牌就相当于认证了,如果确定是用户,就可以根据用户查询对应的权限,根据对应的权限放行对应的服务上,后来决定这样太麻烦了,就在服务上认证了



有自定义过滤器,

### Spring Cloud Config 配置文件





## SpringData



### 



# Tool

### Git

### Maven

### Linux

### Zookeeper

### dubbo

### RibbitMQ

### ElasticSearch

数据库引擎

innoDB 索引文件和数据文件在一起

MyISAM 不支持事务  会分开索引文件和数据文件

### 

# 购物车模块

### 业务流程

* 用户提交商品==>判断是否登录==>登录后查看在Redis数据库中是否又相同的商品==>如果没有直接添加
* 如果没有登录,踢回登录页面

* 如果在数据库中有对应商品,取出后修改参数,在存回去

### 1.怎么处理登录后才能操作购物车

我们的购物车模块是必须要求用户登录后才能进行操作,因为这里是按照京东的购物车作为样本写的,所以在我们需要在登录后才能加入和查询购物车,如果用户没有登录就要加入购物车或者查看购物车,我们都会把用户踢回登录页面,让用户登录完成后,在跳转回加入购物车的页面,在把商品加入到购入车中

### 2.存入Redis的相关注意

我们将购物车的数据存入到Redis数据库中,采用存储Redis的数据类型是hash,因为这个hash有两个key,第一个key我们用来存储用户的信息,比如用户的账号作为该用户的唯一标识,不然我们到时候查询的时候就不知道哪个购物车对应哪个用户了,第二个key我们用来存储商品的id, 因为一个购物车中有多个商品,我们要区分不同的商品,最好的方法就是要商品的id作为唯一标识来对其商品做跟踪,

### 3.同款商品的解决方案

一般用户只会购买一件商品,这样的话我们直接存入Redis数据库就可以了,但是有些用户不会只卖一件.这样就会照成有两件相同的商品,这样会照成一个问题,同个用户买重复的商品不会叠加而是会覆盖,而我们的解决方案是,先查询对应用户下是否有对应的相同商品.如果有就将Redis中的相同商品的数据取出,修改他的总数量和总金额,再存入Redis中,从而达到叠加购买的效果

### 4.精度丢失问题

因为商品的id(sku_id)是Long类型,页面输出的时候会存在精度丢失的问题,让其输出的商品id不对,我们想出了两个解决方案

一.直接改pojo中的字段类型为string,存入的时候将商品id转为string即可

二.在pojo的字段上加上json的序列化注解

```java
@JsonSerialize(using = ToStringSerializer.class)
```

最终是用了第二种

### 5.持久化问题

我们直接采用Redis的默认持久化技术`(RDB)快照形式`来定期将数据保存到磁盘中,它会产生一个文件叫dump.rdb

固定字段:订单id和数量

### 6.关于订单过期问题(如何节省Redis的内存开销)

我们这边已经在存入Redis的时候设置他的过期时间,这样就不会照成内存消耗过大,一般这个时间我们设置为一个月,如果用户真心想买就早就买了,基本不会托这么久的,如果心里上真过意不去就要阿里的短信服务给用户发条短信,提前通知它,我们将在多少天后清空您的购物车





