# 算法

## 排序算法

### 1.冒泡算法

技巧:两个循环,length-1  length-1-x

```java
/*
    冒泡排序：
        一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，
        依次对所有的数据进行操作，直至所有数据按要求完成排序
 */
public class ArrayDemo {
    public static void main(String[] args) {
        //定义一个数组
        int[] arr = {7, 6, 5, 4, 3};
        System.out.println("排序前：" + Arrays.toString(arr));

        // 这里减1，是控制每轮比较的次数
        for (int x = 0; x < arr.length - 1; x++) {
            // -1是为了避免索引越界，-x是为了调高比较效率
            for (int i = 0; i < arr.length - 1 - x; i++) {
                if (arr[i] > arr[i + 1]) {
                    int temp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = temp;
                }
            }
        }
        System.out.println("排序后：" + Arrays.toString(arr));
    }
}
```

### 2.选择排序

```java
/*
    选择排序：
        另外一种排序的方式，选中数组的某个元素,其后面的元素依次和选中的元素进行两两比较，将较大的数据放在后面，依次从前到后选中每个元素，直至所有数据按要求完成排序
 */
public class ArrayDemo {
    public static void main(String[] args) {
        //定义一个数组
        int[] arr = {7, 6, 5, 4, 3};
        System.out.println("排序前：" + Arrays.toString(arr));
  		// 这里减1，是控制比较的轮数
        for (int x = 0; x < arr.length - 1; x++) {
            // 从x+1开始,直到最后一个元素
            for (int i = x+1; i < arr.length; i++) {
                if (arr[x] > arr[i]) {
                    int temp = arr[x];
                    arr[x] = arr[i];
                    arr[i] = temp;
                }
            }
        }
        System.out.println("排序后：" + Arrays.toString(arr));
    }
}
```

## 查找树算法

### 二分查找树代码实现

前提:`二分查找的前提, 数组必须有序`

```java
	public static void main(String[] args) {
        int[] arr = {10, 14, 21, 38, 45, 47, 53, 81, 87, 99};
        int index = binarySerach(arr, 38);
        System.out.println(index);
	}
	/**
     * 二分查找方法
     * @param arr 查找的目标数组
     * @param number 查找的目标值
     * @return 找到的索引,如果没有找到返回-1
     */
    public static int binarySerach(int[] arr, int number) {
        int start = 0;
        int end = arr.length - 1;

        while (start <= end) {
            int mid = (start + end) / 2;
            if (number == arr[mid]) {
                return mid + 1;
            } else if (number < arr[mid]) {
                end = mid - 1;
            } else if (number > arr[mid]) {
                start = mid + 1;
            }
        }
        return -1;  //如果数组中有这个元素，则返回
    }
```



# JavaSE

## 面向对象 

### 面向对象和面向过程的理解

- 面向过程:是一种编程思想
- 面向对象:是一种编程思想
- 区别:
  - 面向过程:注重的是步骤,必须清楚每一个步骤,按照步骤一步一步去实现
  - 面向对象:注重的是对象,无须清楚每一个步骤,只需要使用对象调用行为来完成需求

### 封装 

总结:因为成员变量直接给用户访问会有修改的风险,所以我们将它存入到一个专门的类中,并且私有化,如果我们想要使用,通过get/set方法来使用,提高了代码的安全性和复用性,我们可以在get/set方法中对字段进行增强或做校验

### 继承

* 子类继承了父类`除构造方法外的所有内容`,不过私有方法不能直接调用
* 提高了代码的复用性

* 但耦合度强

### 多态

`多态的前提`：

继承或者实现的关系+父类引用指向子类对象

`总结多态特点`

对于方法：编译看左，运行看右。

对于成员变量：编译看左，运行也看左。 

### 接口

#### 记忆点：规范

也是class文件，就是为对象的使用提供一套**规范**，比如JDBC如果数据库产商在没有接口的情况下，都去编写自己的操作数据库实现类，就会造成很多的乱象，比如方法名千奇百怪，这对开发者来说是很麻烦的。

接口的方法实际上是public abstract  void 方法名()，当通常都省略权限修饰符和abstract关键字，因为接口的方法既然是规范，它必定是公开且无实现的。

#### interface接口和abstract抽象类的区别：

相同：都不能通过new来实例化，如果继承/实现，必须实现抽象方法。

不同：抽象类拥有构造方法，给子类使用，接口中没有

            接口的成员变量必须是常量(final修饰)，而抽象类可以任意类型
    
            实现接口必须实现所有方法，而抽象类可以选择性实现，但该类还是抽象类
    
            接口没有静态代码块和静态方法(jdk1.9才有)，抽象类有
    
            抽象类单继承，而接口可以多实现

**当关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。**

## 集合

![image-20210103115131257](D:\Java笔记_Typora\我添加的img\image-20210103115131257.png)

### 1.Conllection单列集合

![01_单列集合的继承体系](D:\Java笔记_Typora\我添加的img\01_单列集合的继承体系.png)

底层基于数组实现，解决数组扩容复杂等问题。

常用结构：Collection父类接口

List接口 三有集合:有索引,有序,有重复

```java
                        -----ArrayList  基于数组 初始容量为10 add()时扩容数组
                        -----LinkedList 基于链表
                        -----Vector     线程安全
```
Set接口  三无集合:无索引,无序,无重复

```java
             -----HashSet-----LinkedHashSet
             -----TreeSet
```



### 2.Map双列集合

![image-20210103115202353](D:\Java笔记_Typora\我添加的img\image-20210103115202353.png)

#### 一、HashMap的底层实现

`数据结构: `数组+链表+红黑树

`时间复杂度:`O1 总结:因为拿的是数组高效查询,并根据键值找到哈希桶的位置

`初始化:`会初始化16个桶,但初始化的条件是put第一个数,因为他是懒加载的形式

`扩容条件:`当负载因子到0.75的时候会进行2倍的扩容

`怎么扩容:`原来的数据会根据**高低位链**的划分，低位链不变,高位链会根据(原索引+原长度)划分到扩容区中

`插入的方法:`采用的是尾插法

HashMap主要做了两件事,分别是`扰乱函数`和`路由寻址`

`扰乱函数`:在底层是key的hashCode值,主要是用高16位异或低16位,算出地址值,`目的`是为了然地址值更加散列

而算出的数和HanhMap中的值相同,就会引起`哈希冲突`,一般我们用`拉链法`解决这个问题

`路由寻址:`是通过(n-1)&hash来获取的地址值,n是桶的长度,hash就扰乱函数算出来的地址

`树化:`当链表的数量达到8的时候或者容量到64的时候就回树化,`链表会转为红黑树`

`退化:`当链表的数量从8到6了以后就会产生退化,`红黑树转回链表`

因为是

```java
//哈希桶
[<key,value>,<key,value>-><key,value>-><>(链表),<>,<>,<>...<>,<>,<>,<>]//初始长度16
```

![04_jdk1.8的HashMap](D:\Java笔记_Typora\我添加的img\04_jdk1.8的HashMap.png)

### 3.线程安全的集合

#### Lsit集合

* vector 集合
  * 采用的是synchronized同步机制来保证线程安全
  * 但因为太慢都被ArrayList替代使用,不过ArrayList不是线程安全的

#### Map集合的

*  ConcurrentHashMap==>并发hashmap集合
  * 采用的是 CAS自旋 + 局部(synchronized)锁定+Node节点+Unsafe的实现
  * 局部锁定:只锁定桶,不锁定元素
* HashTable  =========>hash表
  * 采用的是synchronized同步机制来保证线程安全



## 多线程

### Thread多线程

线程并发基本概念：多个线程相互抢占资源。

#### 一、线程创建方式:

​	1、实现方式:实现Runable接口重写run()，并new Thread(Runable)

​	2、继承方式:创建类继承Thread类，重写run()，创建该类的对象既可

​	3、内部类方式:直接new Runable接口,重写run()方法

有些地方开线程会new Tread()并存入ArrayList，遍历集合同时开线程

##### 实现Runnable接口比继承Thread类所具有的优势：

1. 适合多个相同的程序代码的线程去共享同一个资源。
2. 可以避免java中的单继承的局限性。
3. 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。
4. 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。

##### Runnable和Callable区别(记忆点：能否返回执行结果)

都是线程任务，但Callable重写call()，如果提交线程池会得到Future的返回值，通过FutureTask.get()可以返回执行结果。

#### 二、线程池

##### 什么时候使用线程池？

- 单个任务处理时间比较短
- 需要处理的任务数量很大

##### 创建方法:

* `方法1:`默认线程池是Executor框架的下的一个分支,但这个框架不是线程池
  * 使用线程类Executors.newFixedThread(线程数量)得到ExectorService线程池对象，
  * 需要提交线程可以直接使用ExectorService的submit(Runable)，
  * 但不推荐因为有可能出现**OOM**因此可以使用
* `方法2`阿里推荐的线程池
  * new ThreadPoolExecutor(1,2,3,4,5)
  * 参数分别是：
    * 线程核心数、
    * 最大执行数，
    * 超过核心数等待时间、
    * 时间单位、
    * 阻塞队列(等待的线程会进去，指定长度)
      * 时间单位格式是TimeUnit.H/M/S
        阻塞队列格式是new ArrayBlockingQueue<>(队列长度)

#### 三、线程安全

* 线程安全：多个线程对`同一个数据`进行访问(取值修改等操作)，从而产生的数据无法达到期望值的一种安全问题。

##### volatile关键字

volatile修饰的数据，具有可见性，禁止了指令重排序，但不具有原子性，比如循环i++，并同时开几个线程，会发现结果并不正确 

##### Synchronized关键字

同步锁

基本概念:通过类对象进行加锁，相同锁的线程会相互等待，如果是加在方法上，默认使用当前类实例对象(静态方法使用类的class)，加锁发生异常会自动释放锁，而**lock**锁则不会自动释放。

##### 底层原理：跟jvm指令和monitor有关(硬件方面还跟内存屏障有关)

当使用synchronized关键字，底层编译的jvm指令中，会有monitorenter和monitorexit两个指令

比如说线程一先拿到了该对象的锁，对象的monitor计数器就会从0变成1，线程二还想进来加锁发现计数器不是0就会进入阻塞状态，monitor支持重入加锁比如

```java
synchronized(){--->线程一拿到锁 计数器+1
    //代码 清空工作内存 拿到主存的数据
    synchronized(){----计数器+1
        //代码执行
        //代码结束执行monitorexit释放锁 计数器-1
    }
        //代码结束执行monitorexit释放锁 计数器-1=0
}
```



##### 悲观锁

synchronized是一种**悲观锁**/独占锁(被害妄想症患者)，无论如何都会加锁防止其他线程的迫害。

Lock锁也可以实现悲观的线程安全，一般使用其实现类ReentrantLock，加锁lock

(),解锁unlock(),发送异常会导致没有释放锁产生死锁的问题。

最常见的就是使用`同步锁来执行`



##### 乐观锁

JDK1.5后新增并发包java.util.concurrent.*，其中的类使用**CAS**算法实现了同步线程安全，这叫**乐观锁**。

```java
比如 AtomicInteger num =new Atomicinteger(n) //原子数n
```

CAS(compare and set)是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

##### CAS实现原理

(原子类AtomicInteger源码为例)：

 ```java
//当调用这个方法
public final int getAndAdd(int delta) { //相当于i++
        return unsafe.getAndAddInt(this, valueOffset, delta);
    }

 public final int getAndAddInt(Object o, long Offset, int delta) {
     int v;
        do {  //o  内存值
            v = this.getIntVolatile(o, Offset);//拿到旧值v
            //v + delta 新值
        } while(!this.compareAndSwapInt(o, Offset, v, v + delta));//CAS(compare and set)

        return v;
    }

线程一会先获取内存值1，当做旧值，进行+操作，得到新值，再重新获取内存值2(有可能被抢执行权)，把这两个内存值进行比较，相同就结束循环，不同就重复上述操作。
    这个循环的操作就叫做自旋
 ```

![CAS](D:\Java笔记_Typora\我添加的img\CAS.png)

**ABA**：CAS出现的问题

两个线程操作数据会发生数据的无意义操作，比如线程二对数据进行了+1-1的操作，线程一发现数据没变，就会进行修改，这时可以通过加版本号的方式来解决这个问题

**相关并发包**

CountDownLatch：可以让线程等待其他线程完成(阻塞)再进行

CyclicBarrier：当多条线程到达屏障点，可以触发新的线程任务

Semaphore:  获取到许可证，就执行否则就等待

Exchanger：线程之间交换数据

##### 死锁

前提：同步的嵌套(不一样的锁) 线程一拿着锁A等锁B，线程二拿着锁B等锁A

```java
synchronized(A){                           
    synchronized(B){                                       
      //线程一                                  
    }                                  
}
synchronized(B){                           
    synchronized(A){                                       
      //线程二                                  
    }                                  
}      
```

## JVM

### 首先是Jaca程序的执行流程

将.java文件-->编译-->class文件-->加载到类加载器上-->加载进JVM中（设计双亲委派机制）责任链模式

类加载机制有三种：全盘负责，双亲委派，缓存机制

### java堆和栈的区别

栈解决程序运行问题，堆解决数据储存的问题，**栈处理逻辑，堆处理数据**，栈中存的是`基本数据类型`和`对象的引用`，堆只负责储存对象信息

### 首先要清楚：JVM中一次完整的`GC流程`是怎么样的

java堆是由新生代和老年代组成的，新生代又是由伊甸+s1+s2组成的，新创建出来的对象会存放在Eden中，`当Eden满了`就会执行**minorGC**`音标/mai ne GC/`，

然后存活下来的对象放进servivor，假设年龄为**1**，多次回收之后`如果servivor对象中年龄超过15的`，他们就会被`转移到老年代`，还有就是**大对象**（需要大量连续内存空间的对象，例如很长的字符串）也会直接进入老年代，最后老年代空间满了就会执行**fullGC**，即

`清理整个内存堆fullGC比MinorGC慢10倍以上`

### JMM Java内存模型

```java
线程会到本地内存/工作内存中拿自己需要操作的数据，而本地内存是从主存中拿到数据并保存为副本的。
线程--->本地内存--->主存
    
public class Account{public static int money =10000;} 
//创建两个线程 线程一方法中while(money=10000){},线程二方法中 sleep一下(为了让线程一先拿到主存中的值)并修改money，这是会发现线程一一直在执行，数据此时没有可见性。

//可见性 线程并不是直接到主存中拿数据的，中间隔了个本地内存，相当于有个带话人一样
    
//原子性 数据的不可分割，典型的比如i++，通过java p可以看到他的操作是分为三步的，这样很容易被抢走执行权，就代表他没有原子性。

//有序性 改变执行的顺序也不影响执行结果 指令重排序执行效率会变高   
```

### JMM:java内存模型

还有8种内存交互操作

用作主内存：

lock：把一个变量标识为线程独占状态

unlock：把一个处于锁定状态的变量释放出来

read：把一个主内存的变量的值从主内存传输到线程的工作内存，为后面的load动作准备

用作工作内存

load：把read操作从主内存中变量放入工作内存中

use：把工作中变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个命令

assign：把一个从执行引擎中接收到的值放入工作内存的变量副本中

store：把一个工作内存中一个变量的值传送到主内存中，以便后续的write使用

write：把store操作从工作内存中得到的变量的值放入主内存的变量中

## 设计模式

### 简单工厂

创建一个类,让其帮我们创建对象,我们只要根据设置对应的字符串就可以获取该对象

总结:不需要我们去new了,从主动变被动

### 单例模式

- 饿汉式：构造方法私有化，提供个静态的该成员对象，提供静态的方法返回对象

- 懒汉式

  - 返回的静态方法用synchronized修饰，且判断是不是null，null就创建。
  - 用双重检查加上volatile(这里是禁止指令重排序)第一重是判断是否创建对象，第二重是为了保证只有一个创建对象(单例)

- 双检模式

  - 一次是在同步外判断是否为空
  - 一次是在同步内判断是否为空

  ![image-20210103095430131](D:\Java笔记_Typora\我添加的img\image-20210103095430131.png)



## 异常

### 1.捕获异常。

我们通常用**try-catch**的方式来捕获异常,注意finally代码块,因为在写IO流等有必须要执行的代码时就需要这个代码块

### 2.自定义异常

要throw抛出我们自己new的异常

### 异常结构图

![image-20210103105422845](D:\Java笔记_Typora\我添加的img\image-20210103105422845.png)

# 数据库

## MySQL数据库

采用的是B+树的结构

常用的数据库引擎

innoDB 索引文件和数据文件在一起(用于事务和保存点)

MyISAM 不支持事务  会分开索引文件和数据文件(一般用于查询)

### 常用的有两个数据引擎:

* `InnoDB`默认开启 的数据引擎
  * 支持事务
  * 支持分布式事务规范(XA)
  * 保存点(用于恢复固定时间点的数据)
    * 比如:9点有个保存点,现在数据已经是10点的更新了很多次,但我们还能恢复到9点的数据
* `MyISAM `需要在创建表的时候需要在engine属性上指定
  * 不支持事务(查询的时候才会用)

总结:如果读多写少,并且对原子性要求低的可以使用MyISAM,但我们一般都会用innoDB引擎,因为,就原子性低这一点就很难让人接收

### Canal监控数据库日记

内置有增加,删除,修改的监听方法,可以对监听到的操作做增强操作,`比如:`导入Es数据结束后,我们可以使用这个技术来监听数据库中的数据是否有改动,如果有就需要更新ES数据库中的信息

### sql语句

#### CRUD

C ==> 增加

R ==> 查询

U ==> 修改

D ==> 删除

#### Insert into 增加

Insert into 表名(要添加的字段) values(要添加的内容)

例子: insert into user(name,sex) values("王子威",18)

#### delete 删除

#### select 查询

#### updata 修改

#### GROUP BY 分组

SELECT password,COUNT(password)
FROM user GROUP BY password

#### limit排序



### 索引

#### 索引是什么

唯一标识,一张表中可用有16索引,但一般我们最多6索引就可以了

先看看数据库日志,定位到查询较慢的sql表,然后对sql表进行三范式的优化

* 第一范式:原子性(做到字段不可再分)
* 第二范式:唯一性(拆分表,一张表只说明一个事务)
* 第三范式:需要中间表(设置主键和外键,不存在传递依赖)

a. explain select语句；

b. 当只要⼀条数据时使⽤limit 1；

c. 为搜索字段建索引；

d. 避免select *；会全表搜索

e. 字段尽量使⽤not null；会全表搜索

f. 垂直分割；

g. 拆分⼤的delete和insert语句：delete和insert会锁表；

h. 分表分库分区。

i. group by 尽量改成 order by或者where

j.尽量不使用like %内容  ,因为前%会全表搜索

k.尽量避免or，in，not，!=

l.有or的地方可以使用union替待

m.用到in的地方可以使用exists替代

n.尽量避免子查询,尽量单表查询

#### 简单优化

## Redis数据库



### 持久化的两种方式

1.默认快照模式:是直接把内存中的数据保存到⼀个 dump ⽂件中，定时保存，保存策略。（`会丢数据`）

2.手动开启  AOF持久化 :把所有的对Redis的服务器进⾏修改的命令都存到⼀个⽂件⾥，命令的集合。（`影响性能`）

### 数据五种结构和应用场景

* String 字符串类型
  * [key,value]
  * 应用在验证码,[账号,验证码]设置一个过期时间
  * 应用在计数器
* hash 哈希类型
  * [key,[key,value]]
  * 应用在购物车中聚合查询
* List
  * [key,[value,value...]]
  * 多线程下单,排序执行
* Set
  * [key,[value,value],key[value,value]]
  * 用交集的添加方法,来垃圾图片清除
* Zset
  * [key,[value,value]]
  * 会排序,所以常用在游戏排名中

![Image](D:\Java笔记_Typora\我添加的img\Image-1609597457473.png)

# 事务

### 概念

一次操作,要么全部成功,要么全部失败(一个业务出现问题,整个数据都回滚)

### 	特征:ACID

A:原子性:保证程序要不成功,要不失败

C:一致性:更像目的,让其提交前后的数据一致

I : 隔离性:是指在并发时候的状态时,理论上相互不干扰,独立

D:持久性:一旦提交事务成功,就是写进磁盘中

### 并发问题(脏读,幻读,不可重复读)

1.脏读

* 提交未成功
* 但另一个程序就已经读取到了对应的数据进行了相关操作(严重)

2.幻读

* 提交成功,
* 受到insert或delete的干扰
* 一个事务中多次读取的数据不一致
* 原因时受到其他事务影响

3.不可重复读

* 提交成功
* 受到update的干扰
* 一个事务中多次读取的数据不一致
* 原因时受到其他事务影响

### 事务隔离级别

1.Read uncommitted

* 读未提交
* 最不安全,但性能最强
* 有脏读(唯一有脏读的)

2.read committed

* 读已提交
* Oracle默认使用这种
* 无脏读

3.repeatable read

* 重复读
* MySql默认使用这种
* 五脏读

4.Serializable

* 串行化
* 最安全
* 性能最弱

### JDBC事务[一个数据库]

开启事务:beginTransaction

例如:try{提交事务:commit}cacth{ 回滚事务: rollback }

### Mybatis事务[一个数据库]

要sqlSession提交/回滚事务操作



### Spring事务[一个数据库]

个人理解:一般都是有个模板,先主从事务管理器,接着配置事务的通知,开启事务的驱动,在配置事务的切入点表达式,但是一般都是用注解+xml配置,应为这样只需要在需要事务的方法和类上加入事务注解即可

利用AOP的特性,增强方法

在方法或类上加上事务注解:@Transactional



## 分布式事务[多个数据库]

### 我们写的订单模块就是多服务多数据源的案例

* 创建订单:order服务---->changgou_order数据库
* 扣减库存: goods服务 -->changgou_goods数据库
* 增加积分:user服务----->changgou_user数据库

### 应用场景

1.单服务多数据源

2.多服务单数据源

3.多服务多数据源

![image-20201231104735888](D:\Java笔记_Typora\我添加的img\image-20201231104735888.png)

### CAP定理(布鲁尔定理)

C==>一致性:全部数据都要修改

A==>可用性:只要受到用户的请求,服务器就必须给出响应

P==> 分区容错性(地域的分区):分布在不同的子网络中,比如:一个中国,一个台美国

注意:P总是会成立,但A和C无法同时做到,所以只会两两成立

![CAP](D:\Java笔记_Typora\我添加的img\CAP.png)

### 分布式事务的解决方案

#### 1.两段协议提交(2PC)基于XA协议

* 第一阶段:准备工作 首先可开启事务 判断该数据资源是否正常工作
* 第二阶段:提交/回滚
  * 扣钱成功,收钱成功=>提交事务
  * 扣钱或收钱失败  ==>回滚事务
* 软件MyCat分库分表中间组件
  * 基于阿里的cobar开发的

![image-20201231130116157](D:\Java笔记_Typora\我添加的img\image-20201231130116157.png)

#### 2.补偿事务TCC



#### 3.本地消息表(异步确保)

#### 4.MQ事务消息

#### 5.Seata 2PC->改进[我们这里用]

# 框架

## SSM框架

### Mybatis框架

主要运用在Dao层,Mybatis引入了对象关系映射（ORM）就是指把JAVA对象和数据库表中的字段进行关系映射，从而达到

操作Java对象就相当于操作数据库，查询了数据库就自动封装成JavaBean对象。

ORM思想：**Object Relational Mapping** 对象关系映射

**完全**的ORM框架：**Hibernate**，双向映射都实现了

**半ORM**框架：**Mybatis** ，只实现了：关系-->映射 （关系是指关系型数据库）

#### #{}和${}的区别

\#{}是预编译处理，可以防止sql注入，${}是字符串拼接，能用前者就不要用后者，order by只能用${}

#### JavaBean属性名和字段名不一致的情况

方案一：字段起别名 + resultType实现自动映射

方案二：使用resultMap手动映射，在xml中配置好映射名就行

#### Mybatis的数据源

默认是使用自己开发的连接池技术POOLED

默认情况下SqlSession是开启了事物的，需要手动提交

#### Mybatis使用的设计模式：

**构造者模式**：用于隐藏复杂的构造过程，根据配置文件，定制生成对象

**工厂模式**：用于批量生产对象，目的是解耦

**代理模式**：当不能、不方便直接操作时，可以通过代理对象间接操作

#### 动态Sql语句

标签，抽取重复sql语句

#### Mybatis缓存

**一级缓存**：是**SqlSession**对象提供的缓存，在执行一次查询之后，查询的结果（JavaBean对象）会被缓存到Sql中，再次查询相同的数据的时候，Mybatis就会优先从缓存中查询，然后再从数据库查，当调用的Sqlsession对象被修改，添加，删除，conmit，close，clearCache等方法时候，一级缓存被清空

**二级缓存**：是**mapper**级别的缓存，由SqlsessionFactory对象生产的Sqlsession对象，同样的映射器

#### Mapper共享缓存。

缓存是**序列化后的数据，**当从缓存中取数据时候，要进行反序列化成JavaBean对象，要求JavaBean必须实现序列化接口Serializble

一级缓存是默认开启的，二级缓存是需要手动开启的

`执行流程：请求-->二级缓存-->一级缓存-->数据库`

**延迟加载（懒加载）**：只有当真正需要使用数据的时候才发起查询，不适用的时不查询

好处：先从单表查询，需要使用关联数据时，才进行关联数据的查询。单表查询的速度要比多表查询的速度要快，性能更高，内存占用小。

坏处：当需要使用数据才会执行Sql，这样大批量的sql执行的情况下，造成查询等待时间比较长，通常一对多，多对多的情况下才使用懒加载

### Spring框架

Spring是分层的服务端全栈轻量级开源框架，能整合第三方框架和类库,IOC和AOP作为核心

* IOC实现反转控制,也就是工厂解耦,是指把创建对象控制权交给框架做[举例:饭店]
  * 如果service里需要dao,说明service依赖于dao:dao就是一个依赖项
  * 需要什么对象我们就去new什么对象==>偶合性太强,
  * 现在需要什么对象,就去工厂BeanFactory里获取什么对象==>耦合性降低了
  * 总结:由主动变被动
  * 目的:解耦

* AOP面向切面是基于动态代理实现预编译方式,主要内容是切面Aspect.而切面=通知+切入点,最后还要织入也就时生成代理对象的过程,配置方式也是三种(纯xml,注解+xml,纯注解),
  * 目的:可以让我们最相关功能进行增强

#### 一.IOC控制反转(底层工厂解耦)

##### IOC实现反转控制,也就是工厂解耦,是指把创建对象控制权交给框架做[举例:饭店]

* 如果service里需要dao,说明service依赖于dao:dao就是一个依赖项
* 需要什么对象我们就去new什么对象==>偶合性太强,
* 现在需要什么对象,就去工厂BeanFactory里获取什么对象==>耦合性降低了
* 目的:让我们可以更加专注于上层代码的应用,业务成的实现

##### Bean的生命周期

* 单例
  * 容器创建时创建
  * 容器关闭时销毁
* 多例
  * 获取bean对象时创建
  * jvm垃圾回收

##### 注入的常见的三种方式

* set方法注入[常用]
  * 要求:依赖项要有set方法
* 构造方法注入
  * 要求:需要有构造方法,构造方法中每个参数就是一个依赖
*  p名称空间注入
  * 本质还是set注入
  * 需要写p路径
* 配置:在xml的bean中配置即可



#### 二.AOP面向切面(底层动态代理)

1.自己的话:

* AOP面向切面是基于动态代理实现预编译方式,主要内容是切面Aspect.而切面=通知+切入点,最后还要织入也就时生成代理对象的过程,配置方式也是三种(纯xml,注解+xml,纯注解)
* `通知`:(增强的内容)
  * 前置通知
  * 后置通知
  * 异常通知
  * 最终通知
  * 环绕通知(注意:环绕通知包括以上4个通知)
* `切入点`(要增强的方法)
  * execution(表达式)
  * 表达式的格式(说白了就是我们定义方法的格式)
    * 修饰符(可以省略)
    * 返回值类型(支持通配符)
    * 包名.类名(支持通配符,且一个点表示子级;两个点表示后代)
    * 方法名(支持通配符)
    * 形参列(支持通配符,且两个点表示任意参数)
* `织入`
  * 生成代理对象的过程
  * 把切入点和通知进行结合
* 我们使用的Spring的AOP
  * 需要做的
    * 编写目标对象
    * 编写通知
    * 配置切面
  * Spring帮我们做的
    * 根据我们配置的切面,生成代理对象,放到容器里





##### 动态代理

jdk通过接口实现动态代理

cglib是通过修改字节码争强功能



#### Spring中的常用注解：

@Controller 在控制层的注解

@Component 把普通类对象注入spring的ioc容器，相当于xml中的bean。

@Service 在业务服务处理层的注解

@Respository 在到数据层的注解

以上四个都是申明一个bean，其中controller、service、respository底层都是用component来实现的

@Scope：配置bean的作用范围

@PostConstruct：是一个方法级别的注解，用于指定bean的初始化方法

@Autowired：注入依赖

@Conditional：选择性的注册bean

@Profile：可以根据不同环境配置不同的bean，激活不同的配置，底层就是Conditional

#### Spring中用到的设计模式

1. `工厂设计模式` : Spring使用工厂模式通过 BeanFactory 、 ApplicationContext 创建 bean 对

象。

2. `代理设计模式` : Spring AOP 功能的实现。

3. `单例设计模式` : Spring 中的 Bean 默认都是单例的。

4. `模板方法模式` : Spring 中 jdbcTemplate 、 hibernateTemplate 等以 Template 结尾的对数据

库操作的类，它们就使用到了模板模式。

5. 包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访

问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。

6. `观察者模式:`Spring 事件驱动模型就是观察者模式很经典的一个应用。

7. `适配器模式 `:Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配 Controller 。

### Springmvc框架

#### DispatcherServlet

* 名字:前端控制器/核心控制器
* 指派别器做事,自己不做事(老板)
* 步骤
  * 接收用户请求
  * 调用HandlerMapping处理器的映射器
  * 调用HandlerAdapter来调用处理器
  * 调用ViewResolver方法,传递页面路径,找视图(未填充)
  * 调用View视图如安然

#### HandlerMapping

* 名字:处理器的映射器
* 职责:根据请求路径,查找到对应的处理器(Contrller方法)
* 用来找Contorller层
  * Controller里的每个方法:Handler
* 返回:Handler以及拦截器

#### HandlerAdapter

* 名字:处理器的适配器
* 职责:用于调用处理器方法,得到处理并返回结果(调业务)
* 因为Controller有可能是
  * 自定义接口或者第三方的接口
  * 可以通过这个调用
* 返回:ModelAndView

#### ViewResolver

* 名字:视图解析器
* 职责:根据路径找到真实的页面
  * 需要传递页面路径
  * 返回真实页面

#### View

* 名字:视图
* 作用:渲染视图

![04.SpringMVC的详细执行过程](D:\Java笔记_Typora\我添加的img\04.SpringMVC的详细执行过程-1609577316590.png)

## SpringSecurity

* 是什么

Spring Security 是Spring的企业应用系统访问控制的安全框架(权限框架),它充分的利用了IOC和AOP功能,

* 做什么

简化了认证和授权功能,可以自己生成一个简陋的登录页面

* 怎么做[写的项目功能]
  * 用到权限五张表(我写的功能用到七张表)
    * 权限五张表(RBAC)
      * 用户表
      * 用户角色表(中间表)
      * 角色表
      * 角色权限表(中间表)
      * 权限表(授权表)
    * 角色菜单表(中间表)
    * 菜单表(哪个权限该加载的数据页面)
  * 步骤
    * 委托代理过滤器
    * 拦截请求
    * 一系列权限过滤器
    * 请求配置,完成认证功能
    * 认证管理器配置
* 遇到的问题
  * 自定义登录页面
    * 过于简单,需要自己写一个
    * 禁用csrf,不然没有权限
  * 匿名访问资源
    * security="none" 路径
  * 密码加密
    * 用bcryt随机盐加密
  * 密码需要从数据库查询验证
    * 自定义认证了,实现接口UserServiceDetail
    * 根据用户名查询用户表是否存在
    * 不存在,直接返回null
    * 存在,则获取数据库密码
    * 为当前用户授权
    * 将用户名,密码,权限列表返回给框架
  * 密码需要加载保证安全
  * 基于配置文件权限控制(主要用于页面)
  * 基于注解方式权限控制(主要用于Controller层)
    * 开启扫描器
    * 开启权限注解
    * 加一个@PreAuthorize(表达式('权限'));

## 微服务框架

### 一丶SpringBoot

简述：为了简化开发，减少配置文件使用默认配置(**构建一切**)

而且Spring Boot可以单独架构,可以做垂直架构,也可以结合ssm使用,和SpringCloud就是微服务了

#### 自动装配原理

* 在SpringBoot中有个注解叫@SpringBootApplication的组合注解
* 这个注解中有个叫@EnableAutoApplication的组合注解,也就是两个组合注解
* 在这个注解下面有个叫@Import的导入注解,这个注解导入了自动配置的类
* 点进去类中会发现两个get的方法,这两个方法调用的是我们spring.factory工厂的bean的配置文件
* 是以Map的形式装入的key是我们注入的类名,value是对象
* 有了这个集合我们的就就可以实现自动依赖了
* 但是他不是一下只全部写到Bean中,
* 而是通过以一个条件判断注解@ConditionalOnMissingBean来进行判断,
* 看下是否已经注册过bean了,没注册在注册,注册就算了

总结:

1.springboot中提供了丰富的条件注解，条件注解是(1).先去判断注册bean的类是否存在，(2.)再判断该类的bean是否存在，(3).再进行注册

2.在xxxAutoConfiguration配置类中：先用条件注解判断，找到源码中一个spring.factiries的一个文件，这个文件提供了所有的配置类，然后再注册bean到IOC容器中（Ico容器其实就是一个map），这个文件里就相当于之前spring.xml

### 二丶SpringCloud框架

`SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。`

#### 1.Spring Cloud Gateway  网关组件

* 三个特点
  * `路由`
    * 将请求转发到其他服务上
  * `断言`
    * 匹配请求的URL规则
  * `过滤器`
    * 对请求可以做限制或处理
* 应用的场景
  * 限流
  * 认证
  * 鉴权
  * 记录日记等等

在项目中我们一开始是要网关的过滤器来对令牌进行拦截,然后就可以对它的内容进行认证和鉴权,因为我们的令牌用的是JWT的规范来生成的所以在网关中要对应的方法解析令牌就相当于认证了,如果确定是用户,就可以根据用户查询对应的权限,根据对应的权限放行对应的服务上,后来决定这样太麻烦了,就在服务上认证了

有自定义过滤器,

#### 2.Spring Cloud Config 配置文件

因为微服务中可能会有成百上千个服务,如果修改配置文件会十分的困难

一般我们会将配置文件上传到git私服服务器中,然后通过SpringCloud Config配置中心获取私服上的配置文件,在下发各个服务



![image-20210103160844196](D:\Java笔记_Typora\我添加的img\image-20210103160844196.png)

#### 3.Spring Cloud Bus 消息总线

* Bus可以让我们在使用Spring Cloud Congfig配置中心对配置文件实时更新完后,

* 就不需要重新启动我们服务也让配置文件会生效,不过需要集成Mq



#### 4.Spring Cloud Hystrix 熔断

是一个开源的延迟和容错库,可以像空气开关一样,保护整个程序,用这个是为防止出现雪崩效应,让整个服务器网全部崩溃,

`发现问题:`拦截器中一直为null

它的`线程隔离特性`,`如果在微服务之间相互要Fegin调用,ji又开启Feign的熔断`,就会导致`开启两个线程`来执行,就会`导致空指针异常`

`解决方案:`将刺猬的隔离策略从`线程隔离`转换为`信号量隔离`

#### 5.Spring Cloud Eureka 注册中心

本身是一个基于RESTfuls的服务,

其中包含两个组件

* 服务端发现组件
* 客户端发现组件

主要用于定位运行在AWS域中的中层服务,以达到负载均衡和中层服务故障转移的目的

##### Eureka注册中心和Zookeeper的区别?

zookeeper注重一致性,Eureka注重可用性



#### 6.Spring Cloud Bibbon 负载均衡

是一个基于HTTP和TCP协议的客户端负载均衡工具

通过Spring Cloud的封装可以让我们轻松的将REST模板转为客户端的服务调用

通常用在的是服务器集群中,就可以在配置类中配置一个轮询算法或随机算法的方式来执行

#### 7.Feign 远程调用

* 在微服务中可以让各个服务之间进行调用,而且这样就不会让服务之间有雪崩的存在

* 除此之外我们可以还可以通过HTTPClient客户端调用,不过不常用,就因为代码多



![1606634458185](D:\Java笔记_Typora\我添加的img\1606634458185.png)





### SpringData





## Tool

### Doker

是运维用的,一般是Linux中的容器,可以实现资源动态分配

#### Docker和虚拟机有什么区别？

`启动的区别:`Doker的启动速度是秒级,而虚拟机通常需要几分钟

因为doker是轻量级的,对系统的利用率也非常的高,可快速实现服务的部署,但是隔离性和安全想也会弱些

### Git

### Maven

### Linux

#### 1.常用命令

cp==>复制

mv==>剪切

rm==>删除

ll ==>查询

vim==>进入文本

cd==>切换目录



### Zookeeper

zookeeper在CAP上取CP注重一致性,但是可用性有些差,因为主节点Master出问题,剩余节点选举时间过长,大约在30-120s之间,容易让注册瘫痪

### dubbo

### RibbitMQ

优点:解耦+异步+削峰(限流)

MQ分布式事务
	消息发送成功
	消息消费成功
如果不成功
	`问题1:`
		消息发送不成功:
	解决方案:
		确认模式confirm和退回模式return
`问题2:`
		消息消费不成功
	解决方案:
		手动配置ACK机制

`问题3`
	交换出问题
解决:
	死信交换机
	或者缓存Redis中持久化到磁盘		

#### 1.如何进行消息队的技术选型

RabbitMQ是Erlang语言编写,并发性强,性能极好,能达到万级的吞吐量,但如果需要比较高的吞吐量,可用考虑kafka,因为这个可以到十万级吞吐,不过一般万级就可以了

延时很低,可以到微秒级,其他都是毫秒级,

#### MQ的高可用

体现在镜像集群模式,它是一个集群创建queue队列,南无其他集群中也会有这个队列的全部数据,消费者就可以在任意集群中获取

kafka是一个副本机制,节点后面都有一个副本节点,当节点挂了副本在用来顶替,来保证消息的高可用性



### ElasticSearch





# 功能模块

## 购物车模块

### 业务流程

* 用户提交商品==>判断是否登录==>登录后查看在Redis数据库中是否又相同的商品==>如果没有直接添加
* 如果没有登录,踢回登录页面

* 如果在数据库中有对应商品,取出后修改参数,在存回去

### 1.怎么处理登录后才能操作购物车

我们的购物车模块是必须要求用户登录后才能进行操作,因为这里是按照京东的购物车作为样本写的,所以在我们需要在登录后才能加入和查询购物车,如果用户没有登录就要加入购物车或者查看购物车,我们都会把用户踢回登录页面,让用户登录完成后,在跳转回加入购物车的页面,在把商品加入到购入车中

### 2.存入Redis的相关注意

我们将购物车的数据存入到Redis数据库中,采用存储Redis的数据类型是hash,因为这个hash有两个key,第一个key我们用来存储用户的信息,比如用户的账号作为该用户的唯一标识,不然我们到时候查询的时候就不知道哪个购物车对应哪个用户了,第二个key我们用来存储商品的id, 因为一个购物车中有多个商品,我们要区分不同的商品,最好的方法就是要商品的id作为唯一标识来对其商品做跟踪,

### 3.同款商品的解决方案

一般用户只会购买一件商品,这样的话我们直接存入Redis数据库就可以了,但是有些用户不会只卖一件.这样就会照成有两件相同的商品,这样会照成一个问题,同个用户买重复的商品不会叠加而是会覆盖,而我们的解决方案是,先查询对应用户下是否有对应的相同商品.如果有就将Redis中的相同商品的数据取出,修改他的总数量和总金额,再存入Redis中,从而达到叠加购买的效果

### 4.精度丢失问题

因为商品的id(sku_id)是Long类型,页面输出的时候会存在精度丢失的问题,让其输出的商品id不对,我们想出了两个解决方案

一.直接改pojo中的字段类型为string,存入的时候将商品id转为string即可

二.在pojo的字段上加上json的序列化注解

```java
@JsonSerialize(using = ToStringSerializer.class)
```

最终是用了第二种

### 5.持久化问题

我们直接采用Redis的默认持久化技术`(RDB)快照形式`来定期将数据保存到磁盘中,它会产生一个文件叫dump.rdb

固定字段:订单id和数量

### 6.关于订单过期问题(如何节省Redis的内存开销)

我们这边已经在存入Redis的时候设置他的过期时间,这样就不会照成内存消耗过大,一般这个时间我们设置为一个月,如果用户真心想买就早就买了,基本不会托这么久的,如果心里上真过意不去就要阿里的短信服务给用户发条短信,提前通知它,我们将在多少天后清空您的购物车

![image-20210102165132206](D:\Java笔记_Typora\我添加的img\image-20210102165132206.png)

## 订单模块

### 业务功能

存两张表,改了两张表:订单表和订单明细表

主要做了5个功能

1.保存订单

2.保存订单明细

3.扣减库存

4.增加用户积分

5.删除购物车

### 1.获取当前收货人地址

用户数据库中有一个tb_address的表当中几个需要注意的字段

(1).有用户名字段 (被查询 的条件)

(2).默认地址的字段:0 否,1 是(又可以是家,也可能是公司)

(3).有别名字段  写的就是家/公司/学校等等

再用户服务下写一个获取地址列表的方法,然后从token中取用户名作为查询收货地址列表的条件,返回所有的该用户有的收获地址

### 2.加载当前用户的购物车列表数据

根据用户名查询Redis中对应的购物车,然后返回展示数据,就是购物车的展示模块

### 3.订单表分析

我们有个订单表再order库中有个tb_order表,我们需要注意的字段

订单id ------------------------> 通过IDworker生成的

总金额和总数量等------------>从购物车获取的

支付类型 --------------------->页面选择传参的

付款和发货这类的时间设置--> 随着订单的流转进行更新,因为他们的时间都不同

订单来源---------------------> 数据分析系统用的(京东或者淘宝)

交易流水,是否删除等--------->订单的状态

### 4.订单详情表分析

订单详情id

订单id的外键

是否退货

订单明细表又叫快照:记录某个商品在某个时刻的详细信息(不管商品有没有变化,订单明细表都不会变)

问题:明明可以直接用sku_id(商品id)获取就可以动态加载这些数据,为什么不用

原因: 库存数据(价格)会有变化,因为节假日会有优惠和折扣,直接查sku表的价格就不会是那一时刻保存的订单,会减优惠,所以不能用

### 5.保存订单

要idworker生成订单id然后从Redis中获取购物车.再取出购物车中的总金额和总数量等封装到order的pojo中还有状态信息,用户信息等等,将这些数据存入MySQL中

### 6.保存订单明细

然后要同样的方法封装订单明细,订单明细就像购物车的快照一样,需要封装的也就是订单详细id和订单的关联id还需要一个发货状态要注意实时更新,订单业务也就差不多了

### 7.扣减库存

要Feign调用我们的goods的商品模块中的sku修改商品的对应的商品库存就可以了,但要扣减多少呢,这需要从购物车取出商品的id和购买的数量,来锁定扣减的商品和数量

### 8.增加积分

要Feign调用我们的User用户模块,更改积分字段points,让其增加积分即可,我们公司对积分的定义是10元一积分,因为涉及钱,所以我们会精确到分

### 9.删除购物车

然后将Redis 中的购物车给删了,因为我们再提交订单后购物车都会清除,因为没有存在的必要了,我们这里做了一个判断,如果不是购买全部购物车就根据订单id来删除购物车

### 10.调用支付

用户下单后,进入微信支付页面,在支付完成后会有一个回调函数,在回调函数中发送消息到RibbitMQ中,让订单消费消息执行对应业务

### 11.多线程下单

* 需要在启动类中加入@EnableAsync开启异步注解

* 在方法上加上@Async多线程注解
* 在业务中调用该方法即可

我们对下单功能的增强,这里主要是为秒杀业务做准备,因为一改成多线程下单,扣减库存什么的就不能直接操作MySQL数据库了,需要间接重Redis中要list数据类型来达到多线程不会出现超卖的问题等

![image-20210102165046642](D:\Java笔记_Typora\我添加的img\image-20210102165046642.png)



## 单点登录

### 1.跳转登录页面的实现

在Oauth的工程中写一个UserLogin的Controller,然后Web权限配置类中要对登录页面和静态资源(css,js等)放行,改掉SpringSecurity的默认页面,改成我们自己写的登录页面,(指定登录页面和按钮的请求地址),在访问我们受保护的资源的时,需要用户登录的,没有登录踢回到登录页面,这是后我们要到网关过滤器AuthorizeFilter中配置,当没有token时,不再是401响应,这里要重定向跳转的登录页面地址

还要添加跳转回去加入购物车的页面,这里时再到LoginRedirect中的登录上获取到传过来的添加购物车的页面, 将返回的页面放到model域中,前台直接要location中的href跳转,现在只要登录有权限访问就可以直接跳回加入购物车的页面

2.TODO 其他未写

## 广告缓存

需要的注意

广告位:因为广告位置显示不同的广告-->广告位置问题

广告表:不同的为位置下,有广告列表数据  --> 广告表:字段和广告位id

在SQL中查询中用了排序查询Order BY,我们是指定升序



我们通过lua脚本进行操作,使用多级缓存的形式让用户达到最好的体验

* 第一个时数据库,这个必须要有的,是最基础的
* 第二个是Redis主要是减轻MySQL的压力,而且Redis的性能和吞吐量都比数据库高
* 第三个是本地缓存OpenRestry,这里是为用户的体验,因为这样用户就算不断刷新他也不会一直去重复读取Redis数据库,不过我们在这里设置了一个过期时间,毕竟还是占内存的



![1599558319320](D:\Java笔记_Typora\我添加的img\1599558319320-1609560999927.png)



